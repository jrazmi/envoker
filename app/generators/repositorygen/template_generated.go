package repositorygen

// GeneratedTemplate is the consolidated template for generated.go (always regenerated)
// This file contains ALL generated code: models, interfaces, repository methods, and FOP helpers
const GeneratedTemplate = `// Code generated by repositorygen. DO NOT EDIT.
// This file is ALWAYS REGENERATED - do not modify.
// For customizations, see repository.go which embeds the generated types.

package {{.PackageName}}

import (
	"context"
	"fmt"

	"github.com/jrazmi/envoker/core/scaffolding/fop"
	"github.com/jrazmi/envoker/sdk/logger"
{{- range .Imports}}
	"{{.}}"
{{- end}}
)

// ========================================
// MODELS
// ========================================

// Generated{{.EntityName}} represents a {{.EntityNameLower}} entity from the database.
// Use the type alias in repository.go to reference this type, or embed it to extend.
type Generated{{.EntityName}} struct {
{{- range .EntityFields}}
	{{.Name}} {{.GoType}} ` + "`" + `json:"{{.JSONTag}}" db:"{{.DBTag}}"{{if .ValidateTag}} validate:"{{.ValidateTag}}"{{end}}` + "`" + `{{if .Comment}} // {{.Comment}}{{end}}
{{- end}}
}

// Generated{{.CreateStructName}} contains the data needed to create a new {{.EntityNameLower}}.
// Use the type alias in repository.go to reference this type, or embed it to add custom fields.
type Generated{{.CreateStructName}} struct {
{{- range .CreateFields}}
	{{.Name}} {{.GoType}} ` + "`" + `json:"{{.JSONTag}}" db:"{{.DBTag}}"{{if .ValidateTag}} validate:"{{.ValidateTag}}"{{end}}` + "`" + `{{if .Comment}} // {{.Comment}}{{end}}
{{- end}}
}

// Generated{{.UpdateStructName}} contains the data for updating an existing {{.EntityNameLower}}.
// All fields are optional (pointers) to support partial updates.
// Use the type alias in repository.go to reference this type, or embed it to add custom fields.
type Generated{{.UpdateStructName}} struct {
{{- range .UpdateFields}}
	{{.Name}} {{.GoType}} ` + "`" + `json:"{{.JSONTag}}" db:"{{.DBTag}}"{{if .ValidateTag}} validate:"{{.ValidateTag}}"{{end}}` + "`" + `{{if .Comment}} // {{.Comment}}{{end}}
{{- end}}
	UpdatedAt *time.Time ` + "`" + `json:"updated_at" db:"updated_at"` + "`" + ` // Optional override for updated_at
}

// ========================================
// FILTER, ORDERING, PAGINATION (FOP)
// ========================================

// OrderBy constants for sorting
const (
	OrderByPK        = "{{.PKColumn}}"
	OrderByCreatedAt = "created_at"
	OrderByUpdatedAt = "updated_at"
{{- range .Columns}}
{{- if and (ne .Name "created_at") (ne .Name "updated_at") (not .IsPrimaryKey)}}
	OrderBy{{ToPascalCase .Name}} = "{{.Name}}"
{{- end}}
{{- end}}
)

// DefaultOrderBy specifies the default sort order
var DefaultOrderBy = fop.NewBy(OrderByCreatedAt, fop.DESC)

// Generated{{.EntityName}}Filter holds the available fields a query can be filtered on.
// Use the type alias in repository.go to reference this type, or embed it to add custom filters.
type Generated{{.EntityName}}Filter struct {
	SearchTerm *string ` + "`" + `json:"search_term,omitempty"` + "`" + ` // Search across text fields
{{- range .Columns}}
{{- if eq .Name "created_at"}}
	CreatedAtBefore *time.Time ` + "`" + `json:"created_at_before,omitempty"` + "`" + ` // Filter by created_at < value
	CreatedAtAfter  *time.Time ` + "`" + `json:"created_at_after,omitempty"` + "`" + ` // Filter by created_at > value
{{- else if eq .Name "updated_at"}}
	UpdatedAtBefore *time.Time ` + "`" + `json:"updated_at_before,omitempty"` + "`" + ` // Filter by updated_at < value
	UpdatedAtAfter  *time.Time ` + "`" + `json:"updated_at_after,omitempty"` + "`" + ` // Filter by updated_at > value
{{- else if and (not .IsPrimaryKey) (not (Contains .GoType "json.RawMessage"))}}
	{{ToPascalCase .Name}} *{{TrimPrefix .GoType "*"}} ` + "`" + `json:"{{.Name}},omitempty"` + "`" + ` // Filter by {{.Name}}
{{- end}}
{{- end}}
}

// {{.EntityName}}Cursor for cursor-based pagination
type {{.EntityName}}Cursor = fop.Cursor[{{.PKGoType}}, time.Time]

// Decode{{.EntityName}}Cursor decodes a cursor token
func Decode{{.EntityName}}Cursor(token string) (*{{.EntityName}}Cursor, error) {
	return fop.DecodeCursor[{{.PKGoType}}, time.Time](token)
}

// Encode{{.EntityName}}Cursor encodes a cursor for pagination
func Encode{{.EntityName}}Cursor(createdAt time.Time, {{.PKParamName}} {{.PKGoType}}) (string, error) {
	cursor := {{.EntityName}}Cursor{
		OrderValue: createdAt,
		PK:         {{.PKParamName}},
	}
	return cursor.Encode()
}

// ========================================
// STORER INTERFACE
// ========================================

// GeneratedStorer defines the auto-generated storage operations for {{.EntityName}}.
// This interface is regenerated on every schema change.
// To add custom storage methods, embed this interface in your Storer interface in repository.go.
type GeneratedStorer interface {
	// Create inserts a new {{.EntityNameLower}}
	Create(ctx context.Context, input Generated{{.CreateStructName}}) (Generated{{.EntityName}}, error)

	// Get retrieves a {{.EntityNameLower}} by its ID
	Get(ctx context.Context, {{.PKParamName}} {{.PKGoType}}) (Generated{{.EntityName}}, error)

	// Update modifies an existing {{.EntityNameLower}}
	Update(ctx context.Context, {{.PKParamName}} {{.PKGoType}}, input Generated{{.UpdateStructName}}) error

	// Delete removes a {{.EntityNameLower}} by its ID
	Delete(ctx context.Context, {{.PKParamName}} {{.PKGoType}}) error

	// List retrieves {{.EntityNamePlural}} with filters, ordering, and pagination
	List(ctx context.Context, filter Generated{{.EntityName}}Filter, orderBy fop.By, page fop.PageStringCursor, forPrevious bool) ([]Generated{{.EntityName}}, error)
{{- if .HasStatusColumn}}

	// Archive sets the status to 'archived'
	Archive(ctx context.Context, {{.PKParamName}} {{.PKGoType}}) error
{{- end}}
{{- range .ForeignKeys}}

	// {{.MethodName}} retrieves {{$.EntityNamePlural}} for a given {{.RefEntityName}}
	{{.MethodName}}(ctx context.Context, {{.FKParamName}} {{.FKGoType}}, orderBy fop.By, page fop.PageStringCursor, forPrevious bool) ([]Generated{{$.EntityName}}, error)
{{- end}}
}

// ========================================
// GENERATED REPOSITORY
// ========================================

// GeneratedRepository provides default implementations for all {{.EntityName}} CRUD operations.
// Embed this struct in your custom Repository (in repository.go) to inherit default behavior
// that you can selectively override.
type GeneratedRepository struct {
	log    *logger.Logger
	storer Storer
}

// Create inserts a new {{.EntityNameLower}}
func (r *GeneratedRepository) Create(ctx context.Context, input Generated{{.CreateStructName}}) (Generated{{.EntityName}}, error) {
	entity, err := r.storer.Create(ctx, input)
	if err != nil {
		return Generated{{.EntityName}}{}, fmt.Errorf("create {{.EntityNameLower}}: %w", err)
	}
	return entity, nil
}

// Get retrieves a {{.EntityNameLower}} by its ID
func (r *GeneratedRepository) Get(ctx context.Context, {{.PKParamName}} {{.PKGoType}}) (Generated{{.EntityName}}, error) {
	entity, err := r.storer.Get(ctx, {{.PKParamName}})
	if err != nil {
		return Generated{{.EntityName}}{}, fmt.Errorf("get {{.EntityNameLower}}[%v]: %w", {{.PKParamName}}, err)
	}
	return entity, nil
}

// Update modifies an existing {{.EntityNameLower}}
func (r *GeneratedRepository) Update(ctx context.Context, {{.PKParamName}} {{.PKGoType}}, input Generated{{.UpdateStructName}}) error {
	if err := r.storer.Update(ctx, {{.PKParamName}}, input); err != nil {
		return fmt.Errorf("update {{.EntityNameLower}}[%v]: %w", {{.PKParamName}}, err)
	}
	return nil
}

// Delete removes a {{.EntityNameLower}} by its ID
func (r *GeneratedRepository) Delete(ctx context.Context, {{.PKParamName}} {{.PKGoType}}) error {
	if err := r.storer.Delete(ctx, {{.PKParamName}}); err != nil {
		return fmt.Errorf("delete {{.EntityNameLower}}[%v]: %w", {{.PKParamName}}, err)
	}
	return nil
}

// List retrieves {{.EntityNamePlural}} with filters, ordering, and pagination
func (r *GeneratedRepository) List(ctx context.Context, filter Generated{{.EntityName}}Filter, order fop.By, page fop.PageStringCursor) ([]Generated{{.EntityName}}, fop.Pagination, error) {
	// Request one more record than needed to check for next page
	listPage := fop.PageStringCursor{
		Limit:  page.Limit + 1,
		Cursor: page.Cursor,
	}

	// Fetch one more record than requested to determine if there's a next page
	records, err := r.storer.List(ctx, filter, order, listPage, false)
	if err != nil {
		return nil, fop.Pagination{}, fmt.Errorf("query: %w", err)
	}

	returnableRecords := records
	nextCursor := ""

	// If we have more records than the limit, trim the list and set next cursor
	if len(records) > page.Limit {
		returnableRecords = records[:page.Limit]
{{- if .HasCreatedAt}}
		lastRecord := returnableRecords[len(returnableRecords)-1]
{{- if .CreatedAtIsPointer}}
		if lastRecord.CreatedAt == nil {
			return nil, fop.Pagination{}, fmt.Errorf("created_at is nil for cursor encoding")
		}
		nextCursor, err = Encode{{.EntityName}}Cursor(*lastRecord.CreatedAt, lastRecord.{{.PKGoName}})
{{- else}}
		nextCursor, err = Encode{{.EntityName}}Cursor(lastRecord.CreatedAt, lastRecord.{{.PKGoName}})
{{- end}}
		if err != nil {
			return nil, fop.Pagination{}, fmt.Errorf("encode next cursor: %w", err)
		}
{{- else}}
		// Note: Table does not have created_at field, cursor-based pagination unavailable
		nextCursor = ""
{{- end}}
	}

	pagination := fop.Pagination{
		HasPrev:        false,
		Limit:          page.Limit,
		PreviousCursor: "",
		NextCursor:     nextCursor,
		PageTotal:      len(returnableRecords),
	}

	// Check if there's a previous page
	if page.Cursor != "" {
		prevRecords, err := r.storer.List(ctx, filter, order, page, true)
		if err == nil && len(prevRecords) > 0 {
			pagination.HasPrev = true
			if len(prevRecords) == page.Limit {
				// we are re-reversing the order in the storage layer so we should start with the first item instead of the last
				firstRecord := prevRecords[0]
{{- if .CreatedAtIsPointer}}
				if firstRecord.CreatedAt == nil {
					return nil, fop.Pagination{}, fmt.Errorf("created_at is nil for prev cursor encoding")
				}
				pagination.PreviousCursor, err = Encode{{.EntityName}}Cursor(*firstRecord.CreatedAt, firstRecord.{{.PKGoName}})
{{- else}}
				pagination.PreviousCursor, err = Encode{{.EntityName}}Cursor(firstRecord.CreatedAt, firstRecord.{{.PKGoName}})
{{- end}}
				if err != nil {
					return nil, fop.Pagination{}, fmt.Errorf("encode prev cursor: %w", err)
				}
			}
		}
	}

	return returnableRecords, pagination, nil
}
{{- if .HasStatusColumn}}

// Archive sets the status to 'archived'
func (r *GeneratedRepository) Archive(ctx context.Context, {{.PKParamName}} {{.PKGoType}}) error {
	if err := r.storer.Archive(ctx, {{.PKParamName}}); err != nil {
		return fmt.Errorf("archive {{.EntityNameLower}}[%v]: %w", {{.PKParamName}}, err)
	}
	return nil
}
{{- end}}
{{- range .ForeignKeys}}

// {{.MethodName}} retrieves {{$.EntityNamePlural}} for a given {{.RefEntityName}}
func (r *GeneratedRepository) {{.MethodName}}(ctx context.Context, {{.FKParamName}} {{.FKGoType}}, order fop.By, page fop.PageStringCursor) ([]Generated{{$.EntityName}}, fop.Pagination, error) {
	// Request one more record than needed to check for next page
	listPage := fop.PageStringCursor{
		Limit:  page.Limit + 1,
		Cursor: page.Cursor,
	}

	// Fetch records
	records, err := r.storer.{{.MethodName}}(ctx, {{.FKParamName}}, order, listPage, false)
	if err != nil {
		return nil, fop.Pagination{}, fmt.Errorf("query: %w", err)
	}

	returnableRecords := records
	nextCursor := ""

	// If we have more records than the limit, trim the list and set next cursor
	if len(records) > page.Limit {
		returnableRecords = records[:page.Limit]
{{- if $.HasCreatedAt}}
		lastRecord := returnableRecords[len(returnableRecords)-1]
{{- if $.CreatedAtIsPointer}}
		if lastRecord.CreatedAt == nil {
			return nil, fop.Pagination{}, fmt.Errorf("created_at is nil for cursor encoding")
		}
		nextCursor, err = Encode{{$.EntityName}}Cursor(*lastRecord.CreatedAt, lastRecord.{{$.PKGoName}})
{{- else}}
		nextCursor, err = Encode{{$.EntityName}}Cursor(lastRecord.CreatedAt, lastRecord.{{$.PKGoName}})
{{- end}}
		if err != nil {
			return nil, fop.Pagination{}, fmt.Errorf("encode next cursor: %w", err)
		}
{{- else}}
		// Note: Table does not have created_at field, cursor-based pagination unavailable
		nextCursor = ""
{{- end}}
	}

	pagination := fop.Pagination{
		HasPrev:        false,
		Limit:          page.Limit,
		PreviousCursor: "",
		NextCursor:     nextCursor,
		PageTotal:      len(returnableRecords),
	}

	// Check if there's a previous page
	if page.Cursor != "" {
		prevRecords, err := r.storer.{{.MethodName}}(ctx, {{.FKParamName}}, order, page, true)
		if err == nil && len(prevRecords) > 0 {
			pagination.HasPrev = true
			if len(prevRecords) == page.Limit {
				firstRecord := prevRecords[0]
{{- if $.CreatedAtIsPointer}}
				if firstRecord.CreatedAt == nil {
					return nil, fop.Pagination{}, fmt.Errorf("created_at is nil for prev cursor encoding")
				}
				pagination.PreviousCursor, err = Encode{{$.EntityName}}Cursor(*firstRecord.CreatedAt, firstRecord.{{$.PKGoName}})
{{- else}}
				pagination.PreviousCursor, err = Encode{{$.EntityName}}Cursor(firstRecord.CreatedAt, firstRecord.{{$.PKGoName}})
{{- end}}
				if err != nil {
					return nil, fop.Pagination{}, fmt.Errorf("encode prev cursor: %w", err)
				}
			}
		}
	}

	return returnableRecords, pagination, nil
}
{{- end}}
`
