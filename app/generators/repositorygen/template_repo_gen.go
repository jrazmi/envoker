package repositorygen

// RepoGenTemplate is the template for repo_gen.go (always regenerated)
const RepoGenTemplate = `// Code generated by repositorygen. DO NOT EDIT.
// This file contains the Repository method implementations for {{.EntityName}}.

package {{.PackageName}}

import (
	"context"
	"fmt"

	"github.com/jrazmi/envoker/core/scaffolding/fop"
)

// GeneratedStorer defines the auto-generated storage operations for {{.EntityName}}
// This interface is regenerated on every schema change. To add custom methods,
// embed this interface in your Storer interface in repo.go (which is not overwritten).
type GeneratedStorer interface {
	// Create inserts a new {{.EntityNameLower}}
	Create(ctx context.Context, input {{.CreateStructName}}) ({{.EntityName}}, error)

	// Get retrieves a {{.EntityNameLower}} by its ID
	Get(ctx context.Context, {{.PKParamName}} {{.PKGoType}}) ({{.EntityName}}, error)

	// Update modifies an existing {{.EntityNameLower}}
	Update(ctx context.Context, {{.PKParamName}} {{.PKGoType}}, input {{.UpdateStructName}}) error

	// Delete removes a {{.EntityNameLower}} by its ID
	Delete(ctx context.Context, {{.PKParamName}} {{.PKGoType}}) error

	// List retrieves {{.EntityNamePlural}} with filters, ordering, and pagination
	List(ctx context.Context, filter {{.EntityName}}Filter, orderBy fop.By, page fop.PageStringCursor, forPrevious bool) ([]{{.EntityName}}, error)
{{- if .HasStatusColumn}}

	// Archive sets the status to 'archived'
	Archive(ctx context.Context, {{.PKParamName}} {{.PKGoType}}) error
{{- end}}
{{- range .ForeignKeys}}

	// {{.MethodName}} retrieves {{$.EntityNamePlural}} for a given {{.RefEntityName}}
	{{.MethodName}}(ctx context.Context, {{.FKParamName}} {{.FKGoType}}, orderBy fop.By, page fop.PageStringCursor, forPrevious bool) ([]{{$.EntityName}}, error)
{{- end}}
}

// Create inserts a new {{.EntityNameLower}}
func (r *Repository) Create(ctx context.Context, input {{.CreateStructName}}) ({{.EntityName}}, error) {
	entity, err := r.storer.Create(ctx, input)
	if err != nil {
		return {{.EntityName}}{}, fmt.Errorf("create {{.EntityNameLower}}: %w", err)
	}
	return entity, nil
}

// Get retrieves a {{.EntityNameLower}} by its ID
func (r *Repository) Get(ctx context.Context, {{.PKParamName}} {{.PKGoType}}) ({{.EntityName}}, error) {
	entity, err := r.storer.Get(ctx, {{.PKParamName}})
	if err != nil {
		return {{.EntityName}}{}, fmt.Errorf("get {{.EntityNameLower}}[%v]: %w", {{.PKParamName}}, err)
	}
	return entity, nil
}

// Update modifies an existing {{.EntityNameLower}}
func (r *Repository) Update(ctx context.Context, {{.PKParamName}} {{.PKGoType}}, input {{.UpdateStructName}}) error {
	if err := r.storer.Update(ctx, {{.PKParamName}}, input); err != nil {
		return fmt.Errorf("update {{.EntityNameLower}}[%v]: %w", {{.PKParamName}}, err)
	}
	return nil
}

// Delete removes a {{.EntityNameLower}} by its ID
func (r *Repository) Delete(ctx context.Context, {{.PKParamName}} {{.PKGoType}}) error {
	if err := r.storer.Delete(ctx, {{.PKParamName}}); err != nil {
		return fmt.Errorf("delete {{.EntityNameLower}}[%v]: %w", {{.PKParamName}}, err)
	}
	return nil
}

// List retrieves {{.EntityNamePlural}} with filters, ordering, and pagination
func (r *Repository) List(ctx context.Context, filter {{.EntityName}}Filter, order fop.By, page fop.PageStringCursor) ([]{{.EntityName}}, fop.Pagination, error) {
	// Request one more record than needed to check for next page
	listPage := fop.PageStringCursor{
		Limit:  page.Limit + 1,
		Cursor: page.Cursor,
	}

	// Fetch one more record than requested to determine if there's a next page
	records, err := r.storer.List(ctx, filter, order, listPage, false)
	if err != nil {
		return nil, fop.Pagination{}, fmt.Errorf("query: %w", err)
	}

	returnableRecords := records
	nextCursor := ""

	// If we have more records than the limit, trim the list and set next cursor
	if len(records) > page.Limit {
		returnableRecords = records[:page.Limit]
		lastRecord := returnableRecords[len(returnableRecords)-1]
{{- if .CreatedAtIsPointer}}
		if lastRecord.CreatedAt == nil {
			return nil, fop.Pagination{}, fmt.Errorf("created_at is nil for cursor encoding")
		}
		nextCursor, err = Encode{{.EntityName}}Cursor(*lastRecord.CreatedAt, lastRecord.{{.PKGoName}})
{{- else}}
		nextCursor, err = Encode{{.EntityName}}Cursor(lastRecord.CreatedAt, lastRecord.{{.PKGoName}})
{{- end}}
		if err != nil {
			return nil, fop.Pagination{}, fmt.Errorf("encode next cursor: %w", err)
		}
	}

	pagination := fop.Pagination{
		HasPrev:        false,
		Limit:          page.Limit,
		PreviousCursor: "",
		NextCursor:     nextCursor,
		PageTotal:      len(returnableRecords),
	}

	// Check if there's a previous page
	if page.Cursor != "" {
		prevRecords, err := r.storer.List(ctx, filter, order, page, true)
		if err == nil && len(prevRecords) > 0 {
			pagination.HasPrev = true
			if len(prevRecords) == page.Limit {
				// we are re-reversing the order in the storage layer so we should start with the first item instead of the last
				firstRecord := prevRecords[0]
{{- if .CreatedAtIsPointer}}
				if firstRecord.CreatedAt == nil {
					return nil, fop.Pagination{}, fmt.Errorf("created_at is nil for prev cursor encoding")
				}
				pagination.PreviousCursor, err = Encode{{.EntityName}}Cursor(*firstRecord.CreatedAt, firstRecord.{{.PKGoName}})
{{- else}}
				pagination.PreviousCursor, err = Encode{{.EntityName}}Cursor(firstRecord.CreatedAt, firstRecord.{{.PKGoName}})
{{- end}}
				if err != nil {
					return nil, fop.Pagination{}, fmt.Errorf("encode prev cursor: %w", err)
				}
			}
		}
	}

	return returnableRecords, pagination, nil
}
{{- if .HasStatusColumn}}

// Archive sets the status to 'archived'
func (r *Repository) Archive(ctx context.Context, {{.PKParamName}} {{.PKGoType}}) error {
	if err := r.storer.Archive(ctx, {{.PKParamName}}); err != nil {
		return fmt.Errorf("archive {{.EntityNameLower}}[%v]: %w", {{.PKParamName}}, err)
	}
	return nil
}
{{- end}}
{{- range .ForeignKeys}}

// {{.MethodName}} retrieves {{$.EntityNamePlural}} for a given {{.RefEntityName}}
func (r *Repository) {{.MethodName}}(ctx context.Context, {{.FKParamName}} {{.FKGoType}}, order fop.By, page fop.PageStringCursor) ([]{{$.EntityName}}, fop.Pagination, error) {
	// Request one more record than needed to check for next page
	listPage := fop.PageStringCursor{
		Limit:  page.Limit + 1,
		Cursor: page.Cursor,
	}

	// Fetch records
	records, err := r.storer.{{.MethodName}}(ctx, {{.FKParamName}}, order, listPage, false)
	if err != nil {
		return nil, fop.Pagination{}, fmt.Errorf("query: %w", err)
	}

	returnableRecords := records
	nextCursor := ""

	// If we have more records than the limit, trim the list and set next cursor
	if len(records) > page.Limit {
		returnableRecords = records[:page.Limit]
		lastRecord := returnableRecords[len(returnableRecords)-1]
{{- if $.CreatedAtIsPointer}}
		if lastRecord.CreatedAt == nil {
			return nil, fop.Pagination{}, fmt.Errorf("created_at is nil for cursor encoding")
		}
		nextCursor, err = Encode{{$.EntityName}}Cursor(*lastRecord.CreatedAt, lastRecord.{{$.PKGoName}})
{{- else}}
		nextCursor, err = Encode{{$.EntityName}}Cursor(lastRecord.CreatedAt, lastRecord.{{$.PKGoName}})
{{- end}}
		if err != nil {
			return nil, fop.Pagination{}, fmt.Errorf("encode next cursor: %w", err)
		}
	}

	pagination := fop.Pagination{
		HasPrev:        false,
		Limit:          page.Limit,
		PreviousCursor: "",
		NextCursor:     nextCursor,
		PageTotal:      len(returnableRecords),
	}

	// Check if there's a previous page
	if page.Cursor != "" {
		prevRecords, err := r.storer.{{.MethodName}}(ctx, {{.FKParamName}}, order, page, true)
		if err == nil && len(prevRecords) > 0 {
			pagination.HasPrev = true
			if len(prevRecords) == page.Limit {
				firstRecord := prevRecords[0]
{{- if $.CreatedAtIsPointer}}
				if firstRecord.CreatedAt == nil {
					return nil, fop.Pagination{}, fmt.Errorf("created_at is nil for prev cursor encoding")
				}
				pagination.PreviousCursor, err = Encode{{$.EntityName}}Cursor(*firstRecord.CreatedAt, firstRecord.{{$.PKGoName}})
{{- else}}
				pagination.PreviousCursor, err = Encode{{$.EntityName}}Cursor(firstRecord.CreatedAt, firstRecord.{{$.PKGoName}})
{{- end}}
				if err != nil {
					return nil, fop.Pagination{}, fmt.Errorf("encode prev cursor: %w", err)
				}
			}
		}
	}

	return returnableRecords, pagination, nil
}
{{- end}}
`
