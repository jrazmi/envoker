package pgxstores

// GeneratedStoreTemplate is the consolidated template for generated.go (always regenerated)
// This file contains ALL generated SQL operations and filter/ordering logic
const GeneratedStoreTemplate = `// Code generated by pgxstores. DO NOT EDIT.
// This file is ALWAYS REGENERATED - do not modify.
// For custom queries, see store.go which embeds the generated store.

package {{.PackageName}}

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strings"
{{- if .NeedsTime}}
	"time"
{{- end}}
{{- if .NeedsJSON}}
	"encoding/json"
{{- end}}

	"github.com/jackc/pgx/v5"
	"{{.ModulePath}}/core/repositories/{{.RepoPackage}}"
	"{{.ModulePath}}/core/scaffolding/fop"
	"{{.ModulePath}}/infrastructure/postgresdb"
	"{{.ModulePath}}/sdk/logger"
)

// ========================================
// GENERATED STORE
// ========================================

// GeneratedStore provides default implementations for all {{.Entity}} SQL operations.
// Embed this struct in your custom Store (in store.go) to inherit default behavior
// that you can selectively override.
type GeneratedStore struct {
	log  *logger.Logger
	pool *postgresdb.Pool
}

// Create inserts a new {{.Entity}}
func (s *GeneratedStore) Create(ctx context.Context, input {{.RepoPackage}}.{{.Create}}) ({{.RepoPackage}}.{{.Entity}}, error) {
	{{- if .PKInCreate}}
	// PK is in Create struct - use value from input
	query := ` + "`INSERT INTO {{.Schema}}.{{.Table}} ({{range $i, $f := .CreateFields}}{{if $i}}, {{end}}{{$f.DBColumn}}{{end}}) VALUES ({{range $i, $f := .CreateFields}}{{if $i}}, {{end}}@{{$f.DBColumn}}{{end}}) RETURNING {{range $i, $f := .EntityFields}}{{if $i}}, {{end}}{{$f.DBColumn}}{{end}}`" + `
	{{- else}}
	// PK not in Create struct - let database generate it
	query := ` + "`INSERT INTO {{.Schema}}.{{.Table}} ({{range $i, $f := .CreateFields}}{{if $i}}, {{end}}{{$f.DBColumn}}{{end}}) VALUES ({{range $i, $f := .CreateFields}}{{if $i}}, {{end}}@{{$f.DBColumn}}{{end}}) RETURNING {{range $i, $f := .EntityFields}}{{if $i}}, {{end}}{{$f.DBColumn}}{{end}}`" + `
	{{- end}}

	args := pgx.NamedArgs{
{{- range .CreateFields}}
		"{{.DBColumn}}": input.{{.Name}},
{{- end}}
	}

	rows, err := s.pool.Query(ctx, query, args)
	if err != nil {
		return {{.RepoPackage}}.{{.Entity}}{}, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	record, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[{{.RepoPackage}}.{{.Entity}}])
	if err != nil {
		return {{.RepoPackage}}.{{.Entity}}{}, postgresdb.HandlePgError(err)
	}

	return record, nil
}

// Get retrieves a single {{.Entity}} by ID
func (s *GeneratedStore) Get(ctx context.Context, {{.PKParamName}} {{.PKGoType}}) ({{.RepoPackage}}.{{.Entity}}, error) {
	query := ` + "`SELECT {{range $i, $f := .EntityFields}}{{if $i}}, {{end}}{{$f.DBColumn}}{{end}} FROM {{.Schema}}.{{.Table}} WHERE {{.PK}} = @{{.PKParamName}}`" + `

	args := pgx.NamedArgs{
		"{{.PKParamName}}": {{.PKParamName}},
	}

	rows, err := s.pool.Query(ctx, query, args)
	if err != nil {
		return {{.RepoPackage}}.{{.Entity}}{}, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	record, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[{{.RepoPackage}}.{{.Entity}}])
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return {{.RepoPackage}}.{{.Entity}}{}, fmt.Errorf("{{.Entity}} not found")
		}
		return {{.RepoPackage}}.{{.Entity}}{}, postgresdb.HandlePgError(err)
	}

	return record, nil
}

// Update modifies an existing {{.Entity}}
func (s *GeneratedStore) Update(ctx context.Context, {{.PKParamName}} {{.PKGoType}}, input {{.RepoPackage}}.{{.Update}}) error {
	buf := bytes.NewBufferString("UPDATE {{.Schema}}.{{.Table}} SET ")
	args := pgx.NamedArgs{
		"{{.PKParamName}}": {{.PKParamName}},
	}
	var fields []string

{{- range .UpdateFields}}
	if input.{{.Name}} != nil {
		fields = append(fields, "{{.DBColumn}} = @{{.DBColumn}}")
		args["{{.DBColumn}}"] = *input.{{.Name}}
	}
{{- end}}

	// Always update the updated_at field
	now := time.Now().UTC()
	if input.UpdatedAt != nil {
		args["updated_at"] = *input.UpdatedAt
	} else {
		args["updated_at"] = now
	}
	fields = append(fields, "updated_at = @updated_at")

	// If no fields to update besides updated_at, return early
	if len(fields) == 1 {
		return fmt.Errorf("no fields to update")
	}

	// Join fields and complete the query
	buf.WriteString(strings.Join(fields, ", "))
	buf.WriteString(" WHERE {{.PK}} = @{{.PKParamName}}")

	query := buf.String()
	s.log.DebugContext(ctx, "update {{.Entity}}", "query", query, "{{.PKParamName}}", {{.PKParamName}})

	result, err := s.pool.Exec(ctx, query, args)
	if err != nil {
		return postgresdb.HandlePgError(err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("{{.Entity}} not found")
	}

	return nil
}

// Delete removes a {{.Entity}} by ID
func (s *GeneratedStore) Delete(ctx context.Context, {{.PKParamName}} {{.PKGoType}}) error {
	query := ` + "`DELETE FROM {{.Schema}}.{{.Table}} WHERE {{.PK}} = @{{.PKParamName}}`" + `

	args := pgx.NamedArgs{
		"{{.PKParamName}}": {{.PKParamName}},
	}

	result, err := s.pool.Exec(ctx, query, args)
	if err != nil {
		return postgresdb.HandlePgError(err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("{{.Entity}} not found")
	}

	return nil
}

// List retrieves {{.Entity}} records with filtering, ordering, and cursor pagination
func (s *GeneratedStore) List(ctx context.Context, filter {{.RepoPackage}}.{{.Entity}}Filter, orderBy fop.By, page fop.PageStringCursor, forPrevious bool) ([]{{.RepoPackage}}.{{.Entity}}, error) {
	data := pgx.NamedArgs{}

	// Start building the query
	buf := bytes.NewBufferString(` + "`\n\t\tSELECT\n\t\t\t{{range $i, $f := .EntityFields}}{{if $i}},\n\t\t\t{{end}}{{$f.DBColumn}}{{end}}\n\t\tFROM\n\t\t\t{{.Schema}}.{{.Table}}`" + `)

	// Apply filters
	s.applyFilter(filter, data, buf)

	// Setup configuration for string cursor pagination
	cursorConfig := postgresdb.StringCursorConfig{
		Cursor:     page.Cursor,
		OrderField: orderByFields[orderBy.Field],
		PKField:    "{{.PK}}",
		TableName:  "{{.Table}}",
		Direction:  orderBy.Direction,
		Limit:      page.Limit,
	}

	// Apply cursor pagination
	if page.Cursor != "" {
		err := postgresdb.ApplyStringCursorPagination[time.Time](buf, data, cursorConfig, forPrevious)
		if err != nil {
			return nil, fmt.Errorf("cursorpagination: %s", err)
		}
	}

	// Add ordering
	err := postgresdb.AddOrderByClause(buf, cursorConfig.OrderField, cursorConfig.PKField, cursorConfig.Direction, forPrevious)
	if err != nil {
		return nil, fmt.Errorf("order: %w", err)
	}

	// Add limit
	postgresdb.AddLimitClause(cursorConfig.Limit, data, buf)

	// Execute the query
	query := buf.String()
	s.log.DebugContext(ctx, "list {{.Entity}}", "query", query)

	rows, err := s.pool.Query(ctx, query, data)
	if err != nil {
		return nil, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	entities, err := pgx.CollectRows(rows, pgx.RowToStructByName[{{.RepoPackage}}.{{.Entity}}])
	if err != nil {
		return nil, postgresdb.HandlePgError(err)
	}

	// If we were getting previous page, reverse the results back to correct order
	if forPrevious && len(entities) > 0 {
		for i, j := 0, len(entities)-1; i < j; i, j = i+1, j-1 {
			entities[i], entities[j] = entities[j], entities[i]
		}
	}

	return entities, nil
}
{{- if .HasStatusColumn}}

// Archive sets the status to 'archived'{{if .HasDeletedAt}} and sets deleted_at{{end}}
func (s *GeneratedStore) Archive(ctx context.Context, {{.PKParamName}} {{.PKGoType}}) error {
	data := pgx.NamedArgs{
		"{{.PKParamName}}": {{.PKParamName}},
		"status": "archived",
	}

	query := ` + "`UPDATE {{.Schema}}.{{.Table}} SET status = @status`" + `

	{{- if .HasDeletedAt}}
	data["deleted_at"] = time.Now().UTC()
	query += ` + "`, deleted_at = @deleted_at`" + `
	{{- end}}

	query += ` + "` WHERE {{.PK}} = @{{.PKParamName}}`" + `

	result, err := s.pool.Exec(ctx, query, data)
	if err != nil {
		return postgresdb.HandlePgError(err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("{{.Entity}} not found")
	}

	return nil
}
{{- end}}
{{- range .ForeignKeys}}

// {{.MethodName}} retrieves {{$.Entity}} records by foreign key with cursor pagination
func (s *GeneratedStore) {{.MethodName}}(ctx context.Context, {{.FKParamName}} {{.FKGoType}}, orderBy fop.By, page fop.PageStringCursor, forPrevious bool) ([]{{$.RepoPackage}}.{{$.Entity}}, error) {
	data := pgx.NamedArgs{
		"{{.FKParamName}}": {{.FKParamName}},
	}

	// Start building the query
	buf := bytes.NewBufferString(` + "`\n\t\tSELECT\n\t\t\t{{range $i, $f := $.EntityFields}}{{if $i}},\n\t\t\t{{end}}{{$f.DBColumn}}{{end}}\n\t\tFROM\n\t\t\t{{$.Schema}}.{{$.Table}}\n\t\tWHERE\n\t\t\t{{.FKColumn}} = @{{.FKParamName}}`" + `)

	// Setup configuration for string cursor pagination
	cursorConfig := postgresdb.StringCursorConfig{
		Cursor:     page.Cursor,
		OrderField: orderByFields[orderBy.Field],
		PKField:    "{{$.PK}}",
		TableName:  "{{$.Table}}",
		Direction:  orderBy.Direction,
		Limit:      page.Limit,
	}

	// Apply cursor pagination
	if page.Cursor != "" {
		err := postgresdb.ApplyStringCursorPagination[time.Time](buf, data, cursorConfig, forPrevious)
		if err != nil {
			return nil, fmt.Errorf("cursorpagination: %s", err)
		}
	}

	// Add ordering
	err := postgresdb.AddOrderByClause(buf, cursorConfig.OrderField, cursorConfig.PKField, cursorConfig.Direction, forPrevious)
	if err != nil {
		return nil, fmt.Errorf("order: %w", err)
	}

	// Add limit
	postgresdb.AddLimitClause(cursorConfig.Limit, data, buf)

	// Execute the query
	query := buf.String()
	s.log.DebugContext(ctx, "{{.MethodName}}", "query", query, "{{.FKParamName}}", {{.FKParamName}})

	rows, err := s.pool.Query(ctx, query, data)
	if err != nil {
		return nil, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	entities, err := pgx.CollectRows(rows, pgx.RowToStructByName[{{$.RepoPackage}}.{{$.Entity}}])
	if err != nil {
		return nil, postgresdb.HandlePgError(err)
	}

	// If we were getting previous page, reverse the results back to correct order
	if forPrevious && len(entities) > 0 {
		for i, j := 0, len(entities)-1; i < j; i, j = i+1, j-1 {
			entities[i], entities[j] = entities[j], entities[i]
		}
	}

	return entities, nil
}
{{- end}}

// ========================================
// FILTER & ORDERING HELPERS
// ========================================

// orderByFields maps repository field names to database column names
var orderByFields = map[string]string{
	{{.RepoPackage}}.OrderByPK:        "{{.PK}}",
	{{.RepoPackage}}.OrderByCreatedAt: "created_at",
	{{.RepoPackage}}.OrderByUpdatedAt: "updated_at",
{{- range .OrderByFields}}
	{{$.RepoPackage}}.OrderBy{{.GoName}}: "{{.DBColumn}}",
{{- end}}
}

// applyFilter applies query filters to the SQL query
func (s *GeneratedStore) applyFilter(filter {{.RepoPackage}}.{{.Entity}}Filter, data pgx.NamedArgs, buf *bytes.Buffer) {
	var conditions []string

{{- range .FilterFields}}
{{- if eq .FilterType "exact"}}
	// {{.Comment}}
	if filter.{{.GoName}} != nil {
		conditions = append(conditions, "{{.DBColumn}} = @{{.ParamName}}")
		data["{{.ParamName}}"] = *filter.{{.GoName}}
	}
{{- else if eq .FilterType "timestamp_range"}}
	// {{.Comment}} - before
	if filter.{{.GoName}}Before != nil {
		conditions = append(conditions, "{{.DBColumn}} < @{{.ParamName}}_before")
		data["{{.ParamName}}_before"] = *filter.{{.GoName}}Before
	}

	// {{.Comment}} - after
	if filter.{{.GoName}}After != nil {
		conditions = append(conditions, "{{.DBColumn}} > @{{.ParamName}}_after")
		data["{{.ParamName}}_after"] = *filter.{{.GoName}}After
	}
{{- else if eq .FilterType "numeric_range"}}
	// {{.Comment}} - min
	if filter.Min{{.GoName}} != nil {
		conditions = append(conditions, "{{.DBColumn}} >= @min_{{.ParamName}}")
		data["min_{{.ParamName}}"] = *filter.Min{{.GoName}}
	}

	// {{.Comment}} - max
	if filter.Max{{.GoName}} != nil {
		conditions = append(conditions, "{{.DBColumn}} <= @max_{{.ParamName}}")
		data["max_{{.ParamName}}"] = *filter.Max{{.GoName}}
	}
{{- else if eq .FilterType "has_value"}}
	// {{.Comment}} - has value check
	if filter.Has{{.GoName}} != nil {
		if *filter.Has{{.GoName}} {
			conditions = append(conditions, "{{.DBColumn}} IS NOT NULL AND {{.DBColumn}} != ''")
		} else {
			conditions = append(conditions, "({{.DBColumn}} IS NULL OR {{.DBColumn}} = '')")
		}
	}
{{- end}}
{{- end}}

	// Search term across text fields
	if filter.SearchTerm != nil && *filter.SearchTerm != "" {
		searchPattern := "%" + *filter.SearchTerm + "%"
		searchConditions := []string{}
{{- range .SearchableFields}}
		searchConditions = append(searchConditions, "{{.}} ILIKE @search_term")
{{- end}}
		if len(searchConditions) > 0 {
			conditions = append(conditions, "(" + strings.Join(searchConditions, " OR ") + ")")
			data["search_term"] = searchPattern
		}
	}

	// Apply conditions if any exist
	if len(conditions) > 0 {
		buf.WriteString(" WHERE ")
		buf.WriteString(strings.Join(conditions, " AND "))
	}
}
`
