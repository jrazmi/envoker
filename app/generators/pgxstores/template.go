package pgxstores

const storeTemplate = `// Code generated by storegen. DO NOT EDIT.

package {{.StorePackage}}

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/jackc/pgx/v5"
	"{{.ModulePath}}/core/repositories/{{.RepoPackage}}"
	"{{.ModulePath}}/core/scaffolding/fop"
	"{{.ModulePath}}/infrastructure/postgresdb"
)

// Get retrieves a single {{.Entity}} by ID
func (s *{{.StoreType}}) Get(ctx context.Context, ID string, filter {{.RepoPackage}}.{{.Filter}}) ({{.RepoPackage}}.{{.Entity}}, error) {
	query := ` + "`SELECT {{range $i, $f := .EntityFields}}{{if $i}}, {{end}}{{$f.DBColumn}}{{end}} FROM {{.Schema}}.{{.Table}} WHERE {{.PK}} = @{{.PK}}`" + `

	args := pgx.NamedArgs{
		"{{.PK}}": ID,
	}

	rows, err := s.pool.Query(ctx, query, args)
	if err != nil {
		return {{.RepoPackage}}.{{.Entity}}{}, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	record, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[{{.RepoPackage}}.{{.Entity}}])
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return {{.RepoPackage}}.{{.Entity}}{}, {{.RepoPackage}}.ErrNotFound
		}
		return {{.RepoPackage}}.{{.Entity}}{}, postgresdb.HandlePgError(err)
	}

	return record, nil
}

// Create inserts a new {{.Entity}}
func (s *{{.StoreType}}) Create(ctx context.Context, input {{.RepoPackage}}.{{.Create}}) ({{.RepoPackage}}.{{.Entity}}, error) {
	{{- if .PKInCreate}}
	// PK is in Create struct - use value from input
	query := ` + "`INSERT INTO {{.Schema}}.{{.Table}} ({{range $i, $f := .CreateFields}}{{if $i}}, {{end}}{{$f.DBColumn}}{{end}}) VALUES ({{range $i, $f := .CreateFields}}{{if $i}}, {{end}}@{{$f.DBColumn}}{{end}}) RETURNING {{range $i, $f := .EntityFields}}{{if $i}}, {{end}}{{$f.DBColumn}}{{end}}`" + `

	args := pgx.NamedArgs{
{{- range .CreateFields}}
		"{{.DBColumn}}": input.{{.Name}},
{{- end}}
	}
	{{- else}}
	// PK not in Create struct - let database generate it (via DEFAULT or trigger)
	query := ` + "`INSERT INTO {{.Schema}}.{{.Table}} ({{range $i, $f := .CreateFields}}{{if $i}}, {{end}}{{$f.DBColumn}}{{end}}) VALUES ({{range $i, $f := .CreateFields}}{{if $i}}, {{end}}@{{$f.DBColumn}}{{end}}) RETURNING {{range $i, $f := .EntityFields}}{{if $i}}, {{end}}{{$f.DBColumn}}{{end}}`" + `

	args := pgx.NamedArgs{
{{- range .CreateFields}}
		"{{.DBColumn}}": input.{{.Name}},
{{- end}}
	}
	{{- end}}

	rows, err := s.pool.Query(ctx, query, args)
	if err != nil {
		return {{.RepoPackage}}.{{.Entity}}{}, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	record, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[{{.RepoPackage}}.{{.Entity}}])
	if err != nil {
		return {{.RepoPackage}}.{{.Entity}}{}, postgresdb.HandlePgError(err)
	}

	return record, nil
}

// Update modifies an existing {{.Entity}}
func (s *{{.StoreType}}) Update(ctx context.Context, ID string, input {{.RepoPackage}}.{{.Update}}) error {
	var fields []string
	data := pgx.NamedArgs{
		"{{.PK}}": ID,
	}

{{range .UpdateFields}}
	{{if eq .DBColumn "updated_at"}}// Handle updated_at specially - always set it
	now := time.Now()
	if input.{{.Name}} != nil {
		data["{{.DBColumn}}"] = *input.{{.Name}}
	} else {
		data["{{.DBColumn}}"] = now
	}
	fields = append(fields, "{{.DBColumn}} = @{{.DBColumn}}")
	{{else}}{{if .IsNullable}}if input.{{.Name}} != nil {
		fields = append(fields, "{{.DBColumn}} = @{{.DBColumn}}")
		data["{{.DBColumn}}"] = input.{{.Name}}
	}
	{{else}}fields = append(fields, "{{.DBColumn}} = @{{.DBColumn}}")
	data["{{.DBColumn}}"] = input.{{.Name}}
	{{end}}{{end}}
{{end}}

	if len(fields) == 0 {
		return fmt.Errorf("no fields to update")
	}

	query := fmt.Sprintf(` + "`UPDATE {{.Schema}}.{{.Table}} SET %s WHERE {{.PK}} = @{{.PK}}`" + `, strings.Join(fields, ", "))

	result, err := s.pool.Exec(ctx, query, data)
	if err != nil {
		return postgresdb.HandlePgError(err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("{{.Entity}} not found: %s", ID)
	}

	return nil
}

// Delete removes a {{.Entity}}
func (s *{{.StoreType}}) Delete(ctx context.Context, ID string) error {
	query := ` + "`DELETE FROM {{.Schema}}.{{.Table}} WHERE {{.PK}} = @{{.PK}}`" + `

	args := pgx.NamedArgs{
		"{{.PK}}": ID,
	}

	result, err := s.pool.Exec(ctx, query, args)
	if err != nil {
		return postgresdb.HandlePgError(err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("{{.Entity}} not found: %s", ID)
	}

	return nil
}

// List gets a paginated list of {{.Table}} with filtering and cursor pagination
func (s *{{.StoreType}}) List(ctx context.Context, filter {{.RepoPackage}}.{{.Filter}}, orderBy fop.By, page fop.PageStringCursor, forPrevious bool) ([]{{.RepoPackage}}.{{.Entity}}, error) {
	data := pgx.NamedArgs{}
	aliases := map[string]string{}

	// Start building the query
	buf := bytes.NewBufferString(` + "`" + `
		SELECT
			{{range $i, $f := .EntityFields}}{{if $i}}, {{end}}{{$f.DBColumn}}{{end}}
		FROM
			{{.Schema}}.{{.Table}}` + "`" + `)

	// Apply filters
	s.applyFilter(filter, data, buf, aliases)

	// Setup configuration for string cursor pagination
	cursorConfig := postgresdb.StringCursorConfig{
		Cursor:     page.Cursor,
		OrderField: orderByFields[orderBy.Field],
		PKField:    "{{.PK}}",
		TableName:  "{{.Table}}",
		Direction:  orderBy.Direction,
		Limit:      page.Limit,
	}

	// Apply cursor pagination (for next page)
	if page.Cursor != "" {
		err := postgresdb.ApplyStringCursorPagination(buf, data, cursorConfig, forPrevious)
		if err != nil {
			return nil, fmt.Errorf("cursorpagination: %s", err)
		}
	}

	// Add ordering
	err := postgresdb.AddOrderByClause(buf, cursorConfig.OrderField, cursorConfig.PKField, cursorConfig.Direction, forPrevious)
	if err != nil {
		return nil, fmt.Errorf("order: %w", err)
	}

	// Add limit
	postgresdb.AddLimitClause(cursorConfig.Limit, data, buf)

	// Execute the query
	query := buf.String()

	rows, err := s.pool.Query(ctx, query, data)
	if err != nil {
		return nil, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	records, err := pgx.CollectRows(rows, pgx.RowToStructByName[{{.RepoPackage}}.{{.Entity}}])
	if err != nil {
		return nil, postgresdb.HandlePgError(err)
	}

	// If we were getting previous page, reverse the results back to correct order
	if forPrevious && len(records) > 0 {
		for i, j := 0, len(records)-1; i < j; i, j = i+1, j-1 {
			records[i], records[j] = records[j], records[i]
		}
	}

	return records, nil
}
`
