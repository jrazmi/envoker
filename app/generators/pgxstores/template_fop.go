package pgxstores

// FopTemplate is the template for fop_gen.go
const FopTemplate = `// Code generated by pgxstores. DO NOT EDIT.
// This file contains filter and ordering logic for {{.Entity}}.

package {{.PackageName}}

import (
	"bytes"
	"strings"
	"time"

	"github.com/jrazmi/envoker/core/repositories/{{.RepoPackage}}"
	"github.com/jackc/pgx/v5"
)

// orderByFields maps repository field names to database column names
var orderByFields = map[string]string{
	{{.RepoPackage}}.OrderByPK:        "{{.PK}}",
	{{.RepoPackage}}.OrderByCreatedAt: "created_at",
	{{.RepoPackage}}.OrderByUpdatedAt: "updated_at",
{{- range .OrderByFields}}
	{{$.RepoPackage}}.OrderBy{{.GoName}}: "{{.DBColumn}}",
{{- end}}
}

// applyFilter applies query filters to the SQL query
func (s *Store) applyFilter(filter {{.RepoPackage}}.{{.Entity}}Filter, data pgx.NamedArgs, buf *bytes.Buffer) {
	var conditions []string

{{- range .FilterFields}}
{{- if eq .FilterType "exact"}}
	// {{.Comment}}
	if filter.{{.GoName}} != nil {
		conditions = append(conditions, "{{.DBColumn}} = @{{.ParamName}}")
		data["{{.ParamName}}"] = *filter.{{.GoName}}
	}
{{- else if eq .FilterType "timestamp_range"}}
	// {{.Comment}} - before
	if filter.{{.GoName}}Before != nil {
		conditions = append(conditions, "{{.DBColumn}} < @{{.ParamName}}_before")
		data["{{.ParamName}}_before"] = *filter.{{.GoName}}Before
	}

	// {{.Comment}} - after
	if filter.{{.GoName}}After != nil {
		conditions = append(conditions, "{{.DBColumn}} > @{{.ParamName}}_after")
		data["{{.ParamName}}_after"] = *filter.{{.GoName}}After
	}
{{- else if eq .FilterType "numeric_range"}}
	// {{.Comment}} - min
	if filter.Min{{.GoName}} != nil {
		conditions = append(conditions, "{{.DBColumn}} >= @min_{{.ParamName}}")
		data["min_{{.ParamName}}"] = *filter.Min{{.GoName}}
	}

	// {{.Comment}} - max
	if filter.Max{{.GoName}} != nil {
		conditions = append(conditions, "{{.DBColumn}} <= @max_{{.ParamName}}")
		data["max_{{.ParamName}}"] = *filter.Max{{.GoName}}
	}
{{- else if eq .FilterType "has_value"}}
	// {{.Comment}} - has value check
	if filter.Has{{.GoName}} != nil {
		if *filter.Has{{.GoName}} {
			conditions = append(conditions, "{{.DBColumn}} IS NOT NULL AND {{.DBColumn}} != ''")
		} else {
			conditions = append(conditions, "({{.DBColumn}} IS NULL OR {{.DBColumn}} = '')")
		}
	}
{{- end}}
{{- end}}

	// Search term across text fields
	if filter.SearchTerm != nil && *filter.SearchTerm != "" {
		searchPattern := "%" + *filter.SearchTerm + "%"
		searchConditions := []string{}
{{- range .SearchableFields}}
		searchConditions = append(searchConditions, "{{.}} ILIKE @search_term")
{{- end}}
		if len(searchConditions) > 0 {
			conditions = append(conditions, "(" + strings.Join(searchConditions, " OR ") + ")")
			data["search_term"] = searchPattern
		}
	}

	// Apply conditions if any exist
	if len(conditions) > 0 {
		buf.WriteString(" WHERE ")
		buf.WriteString(strings.Join(conditions, " AND "))
	}
}
`
