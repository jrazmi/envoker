package bridgegen

const FOPTemplate = `// Code generated by bridgegen. DO NOT EDIT.

package {{.PackageName}}

import (
	"fmt"
	"net/http"
	"strconv"
	"time"

	"{{.ModulePath}}/core/repositories/{{.RepoPackage}}"
	"{{.ModulePath}}/core/scaffolding/fop"
)

// queryParams holds raw query string values from the HTTP request
type queryParams struct {
	Limit  string
	Cursor string
	Order  string
	// Filter fields
	SearchTerm string
{{- range .FilterFields}}
{{- if eq .BridgeName "SearchTerm"}}{{/* Skip SearchTerm - already added */}}
{{- else if eq .BridgeName "CreatedAtBefore"}}
	CreatedAtBefore string
{{- else if eq .BridgeName "CreatedAtAfter"}}
	CreatedAtAfter string
{{- else if eq .BridgeName "UpdatedAtBefore"}}
	UpdatedAtBefore string
{{- else if eq .BridgeName "UpdatedAtAfter"}}
	UpdatedAtAfter string
{{- else}}
	{{.BridgeName}} string
{{- end}}
{{- end}}
}

// pathParams holds path parameter values
type pathParams struct {
	{{.PKGoName}} string
{{- range .ForeignKeys}}
	{{.FKGoName}} string
{{- end}}
}

// parseQueryParams extracts raw query string values
func parseQueryParams(r *http.Request) queryParams {
	q := r.URL.Query()
	return queryParams{
		Limit:      q.Get("limit"),
		Cursor:     q.Get("cursor"),
		Order:      q.Get("order"),
		SearchTerm: q.Get("search_term"),
{{- range .FilterFields}}
{{- if eq .BridgeName "SearchTerm"}}{{/* Skip - already added */}}
{{- else if eq .BridgeName "CreatedAtBefore"}}
		CreatedAtBefore: q.Get("created_at_before"),
{{- else if eq .BridgeName "CreatedAtAfter"}}
		CreatedAtAfter:  q.Get("created_at_after"),
{{- else if eq .BridgeName "UpdatedAtBefore"}}
		UpdatedAtBefore: q.Get("updated_at_before"),
{{- else if eq .BridgeName "UpdatedAtAfter"}}
		UpdatedAtAfter:  q.Get("updated_at_after"),
{{- else}}
		{{.BridgeName}}: q.Get("{{.DBColumn}}"),
{{- end}}
{{- end}}
	}
}

// parseFilter converts query params to repository filter with validation
func parseFilter(qp queryParams) ({{.RepoPackage}}.{{.EntityName}}Filter, error) {
	filter := {{.RepoPackage}}.{{.EntityName}}Filter{}

	// SearchTerm filter
	if qp.SearchTerm != "" {
		filter.SearchTerm = &qp.SearchTerm
	}

{{- range .FilterFields}}
{{- if eq .BridgeName "SearchTerm"}}{{/* Already handled above */}}
{{- else if or (eq .BridgeName "CreatedAtBefore") (eq .BridgeName "CreatedAtAfter") (eq .BridgeName "UpdatedAtBefore") (eq .BridgeName "UpdatedAtAfter")}}
	// {{.BridgeName}} - timestamp filter
	if qp.{{.BridgeName}} != "" {
		if t, err := time.Parse(time.RFC3339, qp.{{.BridgeName}}); err == nil {
			filter.{{.BridgeName}} = &t
		} else {
			return filter, fmt.Errorf("invalid {{.DBColumn}} format: %s", qp.{{.BridgeName}})
		}
	}
{{- else if .IsTime}}
	// {{.BridgeName}} - timestamp filter
	if qp.{{.BridgeName}} != "" {
		if t, err := time.Parse(time.RFC3339, qp.{{.BridgeName}}); err == nil {
			filter.{{.BridgeName}} = &t
		} else {
			return filter, fmt.Errorf("invalid {{.DBColumn}} format: %s", qp.{{.BridgeName}})
		}
	}
{{- else if or (Contains .GoType "int") (Contains .GoType "int32") (Contains .GoType "int64")}}
	// {{.BridgeName}} - integer filter
	if qp.{{.BridgeName}} != "" {
		if val, err := strconv.Atoi(qp.{{.BridgeName}}); err == nil {
			filter.{{.BridgeName}} = &val
		} else {
			return filter, fmt.Errorf("invalid {{.DBColumn}}: %s", qp.{{.BridgeName}})
		}
	}
{{- else}}
	// {{.BridgeName}} - string filter
	if qp.{{.BridgeName}} != "" {
		filter.{{.BridgeName}} = &qp.{{.BridgeName}}
	}
{{- end}}
{{- end}}

	return filter, nil
}

// parsePath extracts path parameters
func parsePath(r *http.Request) (pathParams, error) {
	pp := pathParams{
		{{.PKGoName}}: r.PathValue("{{.PKURLParam}}"),
{{- range .ForeignKeys}}
		{{.FKGoName}}: r.PathValue("{{.FKURLParam}}"),
{{- end}}
	}
	return pp, nil
}

// orderByFields maps URL-friendly field names to repository OrderBy constants
var orderByFields = map[string]string{
	"{{.PKURLParam}}": {{.RepoPackage}}.OrderByPK,
	"created_at":      {{.RepoPackage}}.OrderByCreatedAt,
	"updated_at":      {{.RepoPackage}}.OrderByUpdatedAt,
{{- range .FilterFields}}
	"{{.DBColumn}}": {{$.RepoPackage}}.OrderBy{{.BridgeName}},
{{- end}}
}

// parseOrderBy converts order query param to fop.By with validation
func parseOrderBy(order string) fop.By {
	if order == "" {
		return {{.RepoPackage}}.DefaultOrderBy
	}

	// Use FOP's ParseOrder which handles "field,direction" format
	orderBy, err := fop.ParseOrder(orderByFields, order, {{.RepoPackage}}.DefaultOrderBy)
	if err != nil {
		return {{.RepoPackage}}.DefaultOrderBy
	}

	return orderBy
}
`
