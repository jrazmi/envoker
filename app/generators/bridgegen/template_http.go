package bridgegen

const HTTPTemplate = `// Code generated by bridgegen. DO NOT EDIT.
// This file contains HTTP handler methods.
// Route registration is in http.go (user-editable).

package {{.PackageName}}

import (
	"context"
	"net/http"

	"{{.ModulePath}}/bridge/scaffolding/errs"
	"{{.ModulePath}}/bridge/scaffolding/fopbridge"
	"{{.ModulePath}}/core/repositories/{{.RepoPackage}}"
	"{{.ModulePath}}/core/scaffolding/fop"
	"{{.ModulePath}}/infrastructure/web"
)

// ============================================================================
// SUGGESTED ROUTES FOR http.go
// ============================================================================
// Copy the routes you need to http.go's AddHttpRoutes function:
//
//	//// Standard CRUD routes
//	// group.GET("{{.HTTPBasePath}}", b.httpList)
//	// group.GET("{{printf "%s/{%s}" .HTTPBasePath .PKURLParam}}", b.httpGetByID)
//	// group.POST("{{.HTTPBasePath}}", b.httpCreate)
//	// group.PUT("{{printf "%s/{%s}" .HTTPBasePath .PKURLParam}}", b.httpUpdate)
//	// group.DELETE("{{printf "%s/{%s}" .HTTPBasePath .PKURLParam}}", b.httpDelete)
{{- if .ForeignKeys}}
//
{{- range .ForeignKeys}}
//	//// Foreign key route: {{.MethodName}}
//	// group.GET("{{.RoutePath}}", b.{{.MethodName}})
{{- end}}
{{- end}}
// ============================================================================

// httpList handles GET requests for listing {{.EntityNamePlural}} with pagination and filtering
func (b *bridge) httpList(ctx context.Context, r *http.Request) web.Encoder {
	qp := parseQueryParams(r)

	page, err := fop.ParsePageStringCursor(qp.Limit, qp.Cursor)
	if err != nil {
		return errs.NewFieldErrors("page", err)
	}

	filter, err := parseFilter(qp)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid filter: %s", err)
	}

	orderBy := parseOrderBy(qp.Order)

	records, pagination, err := b.{{.EntityNameLower}}Repository.List(ctx, filter, orderBy, page)
	if err != nil {
		return errs.Newf(errs.Internal, "list {{.EntityNamePlural}}: %s", err)
	}

	return fopbridge.NewPaginatedResult(MarshalListToBridge(records), pagination)
}

// httpGetByID handles GET requests for retrieving a specific {{.EntityNameLower}} by ID
func (b *bridge) httpGetByID(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parsePath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	if qpath.{{.PKGoName}} == "" {
		return errs.Newf(errs.InvalidArgument, "{{.PKURLParam}} is required")
	}

	record, err := b.{{.EntityNameLower}}Repository.Get(ctx, qpath.{{.PKGoName}})
	if err != nil {
		return errs.Newf(errs.NotFound, "{{.EntityNameLower}} not found: %s", qpath.{{.PKGoName}})
	}

	return MarshalToBridge(record)
}

// httpCreate handles POST requests for creating a new {{.EntityNameLower}}
func (b *bridge) httpCreate(ctx context.Context, r *http.Request) web.Encoder {
	var input Create{{.EntityName}}Input
	if err := web.Decode(r, &input); err != nil {
		return errs.Newf(errs.InvalidArgument, "decode: %s", err)
	}

	createInput := MarshalCreateToRepository(input)

	record, err := b.{{.EntityNameLower}}Repository.Create(ctx, createInput)
	if err != nil {
		return errs.Newf(errs.Internal, "create {{.EntityNameLower}}: %s", err)
	}

	return MarshalToBridge(record)
}

// httpUpdate handles PUT/PATCH requests for updating an existing {{.EntityNameLower}}
func (b *bridge) httpUpdate(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parsePath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	if qpath.{{.PKGoName}} == "" {
		return errs.Newf(errs.InvalidArgument, "{{.PKURLParam}} is required")
	}

	var input Update{{.EntityName}}Input
	if err := web.Decode(r, &input); err != nil {
		return errs.Newf(errs.InvalidArgument, "decode: %s", err)
	}

	updateInput := MarshalUpdateToRepository(input)

	err = b.{{.EntityNameLower}}Repository.Update(ctx, qpath.{{.PKGoName}}, updateInput)
	if err != nil {
		return errs.Newf(errs.Internal, "update {{.EntityNameLower}}: %s", err)
	}

	return fopbridge.CodeResponse{
		Code:    errs.OK.String(),
		Message: "{{.EntityName}} updated successfully",
	}
}

// httpDelete handles DELETE requests for removing a {{.EntityNameLower}}
func (b *bridge) httpDelete(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parsePath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	if qpath.{{.PKGoName}} == "" {
		return errs.Newf(errs.InvalidArgument, "{{.PKURLParam}} is required")
	}

	err = b.{{.EntityNameLower}}Repository.Delete(ctx, qpath.{{.PKGoName}})
	if err != nil {
		return errs.Newf(errs.Internal, "delete {{.EntityNameLower}}: %s", err)
	}

	return fopbridge.CodeResponse{
		Code:    errs.OK.String(),
		Message: "{{.EntityName}} deleted successfully",
	}
}
{{- range .ForeignKeys}}

// {{.MethodName}} handles GET requests for listing {{$.EntityNamePlural}} by {{.RefEntityName}}
func (b *bridge) {{.MethodName}}(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parsePath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	if qpath.{{.FKGoName}} == "" {
		return errs.Newf(errs.InvalidArgument, "{{.FKURLParam}} is required")
	}

	qp := parseQueryParams(r)

	page, err := fop.ParsePageStringCursor(qp.Limit, qp.Cursor)
	if err != nil {
		return errs.NewFieldErrors("page", err)
	}

	orderBy := parseOrderBy(qp.Order)

	records, pagination, err := b.{{$.EntityNameLower}}Repository.ListBy{{.FKGoName}}(ctx, qpath.{{.FKGoName}}, orderBy, page)
	if err != nil {
		return errs.Newf(errs.Internal, "list {{$.EntityNamePlural}} by {{.FKGoName}}: %s", err)
	}

	return fopbridge.NewPaginatedResult(MarshalListToBridge(records), pagination)
}
{{- end}}
`
