package bridgegen

// GeneratedTemplate is the consolidated template for generated.go (always regenerated)
// This file contains ALL generated bridge code: models, HTTP handlers, marshaling, and FOP helpers
const GeneratedTemplate = `// Code generated by bridgegen. DO NOT EDIT.
// This file is ALWAYS REGENERATED - do not modify.
// For customizations, see model.go and bridge.go which use type aliases and embedding.

package {{.PackageName}}

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"
{{- if .NeedsTimeImport}}
	"time"
{{- end}}

	"{{.ModulePath}}/bridge/scaffolding/errs"
	"{{.ModulePath}}/bridge/scaffolding/fopbridge"
	"{{.ModulePath}}/core/repositories/{{.RepoPackage}}"
	"{{.ModulePath}}/core/scaffolding/fop"
	"{{.ModulePath}}/infrastructure/web"
)

// ========================================
// BRIDGE MODELS
// ========================================

// Generated{{.EntityName}} represents the bridge model for {{.EntityNameLower}}
type Generated{{.EntityName}} struct {
{{- range .EntityFields}}
	{{.BridgeName}} {{.GoType}} ` + "`json:\"{{.DBColumn}}{{if .OmitEmpty}},omitempty{{end}}\"`" + `
{{- end}}
}

// Encode implements the encoder interface
func (t Generated{{.EntityName}}) Encode() ([]byte, string, error) {
	data, err := json.Marshal(t)
	return data, "application/json", err
}

// GeneratedCreate{{.EntityName}}Input represents the input for creating a new {{.EntityNameLower}}
type GeneratedCreate{{.EntityName}}Input struct {
{{- range .CreateFields}}
	{{.BridgeName}} {{.GoType}} ` + "`json:\"{{.DBColumn}}{{if .OmitEmpty}},omitempty{{end}}\"`" + `
{{- end}}
}

// Decode implements the decoder interface
func (c *GeneratedCreate{{.EntityName}}Input) Decode(data []byte) error {
	return json.Unmarshal(data, c)
}

// GeneratedUpdate{{.EntityName}}Input represents the input for updating a {{.EntityNameLower}}
type GeneratedUpdate{{.EntityName}}Input struct {
{{- range .UpdateFields}}
	{{.BridgeName}} {{.GoType}} ` + "`json:\"{{.DBColumn}},omitempty\"`" + `
{{- end}}
}

// Decode implements the decoder interface
func (u *GeneratedUpdate{{.EntityName}}Input) Decode(data []byte) error {
	return json.Unmarshal(data, u)
}

// ========================================
// MARSHALING FUNCTIONS
// ========================================

// MarshalToBridge converts a repository {{.EntityName}} to a bridge {{.EntityName}}
func MarshalToBridge(repo {{.RepoPackage}}.{{.EntityName}}) Generated{{.EntityName}} {
	return Generated{{.EntityName}}{
{{- range .EntityFields}}
		{{.BridgeName}}: repo.{{.RepoName}},
{{- end}}
	}
}

// MarshalListToBridge converts a list of repository {{.EntityNamePlural}} to bridge {{.EntityNamePlural}}
func MarshalListToBridge(repos []{{.RepoPackage}}.{{.EntityName}}) []Generated{{.EntityName}} {
	result := make([]Generated{{.EntityName}}, len(repos))
	for i, repo := range repos {
		result[i] = MarshalToBridge(repo)
	}
	return result
}

// MarshalCreateToRepository converts a bridge Create input to repository Create input
func MarshalCreateToRepository(input GeneratedCreate{{.EntityName}}Input) {{.RepoPackage}}.Create{{.EntityName}} {
	return {{.RepoPackage}}.Create{{.EntityName}}{
{{- range .CreateFields}}
		{{.RepoName}}: input.{{.BridgeName}},
{{- end}}
	}
}

// MarshalUpdateToRepository converts a bridge Update input to repository Update input
func MarshalUpdateToRepository(input GeneratedUpdate{{.EntityName}}Input) {{.RepoPackage}}.Update{{.EntityName}} {
	return {{.RepoPackage}}.Update{{.EntityName}}{
{{- range .UpdateFields}}
		{{.RepoName}}: input.{{.BridgeName}},
{{- end}}
	}
}

// ========================================
// QUERY PARAMS & PATH PARAMS
// ========================================

// generatedQueryParams holds raw query string values from the HTTP request
type generatedQueryParams struct {
	Limit  string
	Cursor string
	Order  string
	// Filter fields
	SearchTerm string
{{- range .FilterFields}}
{{- if eq .BridgeName "SearchTerm"}}{{/* Skip SearchTerm - already added */}}
{{- else if eq .BridgeName "CreatedAtBefore"}}
	CreatedAtBefore string
{{- else if eq .BridgeName "CreatedAtAfter"}}
	CreatedAtAfter string
{{- else if eq .BridgeName "UpdatedAtBefore"}}
	UpdatedAtBefore string
{{- else if eq .BridgeName "UpdatedAtAfter"}}
	UpdatedAtAfter string
{{- else}}
	{{.BridgeName}} string
{{- end}}
{{- end}}
}

// generatedPathParams holds path parameter values
type generatedPathParams struct {
	{{.PKGoName}} string
{{- range .ForeignKeys}}
	{{.FKGoName}} string
{{- end}}
}

// parseGeneratedQueryParams extracts raw query string values
func parseGeneratedQueryParams(r *http.Request) generatedQueryParams {
	q := r.URL.Query()
	return generatedQueryParams{
		Limit:      q.Get("limit"),
		Cursor:     q.Get("cursor"),
		Order:      q.Get("order"),
		SearchTerm: q.Get("search_term"),
{{- range .FilterFields}}
{{- if eq .BridgeName "SearchTerm"}}{{/* Skip - already added */}}
{{- else if eq .BridgeName "CreatedAtBefore"}}
		CreatedAtBefore: q.Get("created_at_before"),
{{- else if eq .BridgeName "CreatedAtAfter"}}
		CreatedAtAfter:  q.Get("created_at_after"),
{{- else if eq .BridgeName "UpdatedAtBefore"}}
		UpdatedAtBefore: q.Get("updated_at_before"),
{{- else if eq .BridgeName "UpdatedAtAfter"}}
		UpdatedAtAfter:  q.Get("updated_at_after"),
{{- else}}
		{{.BridgeName}}: q.Get("{{.DBColumn}}"),
{{- end}}
{{- end}}
	}
}

// parseGeneratedFilter converts query params to repository filter with validation
func parseGeneratedFilter(qp generatedQueryParams) ({{.RepoPackage}}.{{.EntityName}}Filter, error) {
	filter := {{.RepoPackage}}.{{.EntityName}}Filter{}

	// SearchTerm filter
	if qp.SearchTerm != "" {
		filter.SearchTerm = &qp.SearchTerm
	}

{{- range .FilterFields}}
{{- if eq .BridgeName "SearchTerm"}}{{/* Already handled above */}}
{{- else if or (eq .BridgeName "CreatedAtBefore") (eq .BridgeName "CreatedAtAfter") (eq .BridgeName "UpdatedAtBefore") (eq .BridgeName "UpdatedAtAfter")}}
	// {{.BridgeName}} - timestamp filter
	if qp.{{.BridgeName}} != "" {
		if t, err := time.Parse(time.RFC3339, qp.{{.BridgeName}}); err == nil {
			filter.{{.BridgeName}} = &t
		} else {
			return filter, fmt.Errorf("invalid {{.DBColumn}} format: %s", qp.{{.BridgeName}})
		}
	}
{{- else if .IsTime}}
	// {{.BridgeName}} - timestamp filter
	if qp.{{.BridgeName}} != "" {
		if t, err := time.Parse(time.RFC3339, qp.{{.BridgeName}}); err == nil {
			filter.{{.BridgeName}} = &t
		} else {
			return filter, fmt.Errorf("invalid {{.DBColumn}} format: %s", qp.{{.BridgeName}})
		}
	}
{{- else if Contains .GoType "int64"}}
	// {{.BridgeName}} - int64 filter
	if qp.{{.BridgeName}} != "" {
		if val, err := strconv.ParseInt(qp.{{.BridgeName}}, 10, 64); err == nil {
			filter.{{.BridgeName}} = &val
		} else {
			return filter, fmt.Errorf("invalid {{.DBColumn}}: %s", qp.{{.BridgeName}})
		}
	}
{{- else if Contains .GoType "int32"}}
	// {{.BridgeName}} - int32 filter
	if qp.{{.BridgeName}} != "" {
		if val, err := strconv.ParseInt(qp.{{.BridgeName}}, 10, 32); err == nil {
			val32 := int32(val)
			filter.{{.BridgeName}} = &val32
		} else {
			return filter, fmt.Errorf("invalid {{.DBColumn}}: %s", qp.{{.BridgeName}})
		}
	}
{{- else if Contains .GoType "int16"}}
	// {{.BridgeName}} - int16 filter
	if qp.{{.BridgeName}} != "" {
		if val, err := strconv.ParseInt(qp.{{.BridgeName}}, 10, 16); err == nil {
			val16 := int16(val)
			filter.{{.BridgeName}} = &val16
		} else {
			return filter, fmt.Errorf("invalid {{.DBColumn}}: %s", qp.{{.BridgeName}})
		}
	}
{{- else if Contains .GoType "int"}}
	// {{.BridgeName}} - int filter
	if qp.{{.BridgeName}} != "" {
		if val, err := strconv.Atoi(qp.{{.BridgeName}}); err == nil {
			filter.{{.BridgeName}} = &val
		} else {
			return filter, fmt.Errorf("invalid {{.DBColumn}}: %s", qp.{{.BridgeName}})
		}
	}
{{- else if Contains .GoType "float64"}}
	// {{.BridgeName}} - float64 filter
	if qp.{{.BridgeName}} != "" {
		if val, err := strconv.ParseFloat(qp.{{.BridgeName}}, 64); err == nil {
			filter.{{.BridgeName}} = &val
		} else {
			return filter, fmt.Errorf("invalid {{.DBColumn}}: %s", qp.{{.BridgeName}})
		}
	}
{{- else if Contains .GoType "float32"}}
	// {{.BridgeName}} - float32 filter
	if qp.{{.BridgeName}} != "" {
		if val, err := strconv.ParseFloat(qp.{{.BridgeName}}, 32); err == nil {
			val32 := float32(val)
			filter.{{.BridgeName}} = &val32
		} else {
			return filter, fmt.Errorf("invalid {{.DBColumn}}: %s", qp.{{.BridgeName}})
		}
	}
{{- else if Contains .GoType "bool"}}
	// {{.BridgeName}} - boolean filter
	if qp.{{.BridgeName}} != "" {
		if val, err := strconv.ParseBool(qp.{{.BridgeName}}); err == nil {
			filter.{{.BridgeName}} = &val
		} else {
			return filter, fmt.Errorf("invalid {{.DBColumn}}: %s (expected true/false)", qp.{{.BridgeName}})
		}
	}
{{- else}}
	// {{.BridgeName}} - string filter
	if qp.{{.BridgeName}} != "" {
		filter.{{.BridgeName}} = &qp.{{.BridgeName}}
	}
{{- end}}
{{- end}}

	return filter, nil
}

// parseGeneratedPath extracts path parameters
func parseGeneratedPath(r *http.Request) (generatedPathParams, error) {
	pp := generatedPathParams{
		{{.PKGoName}}: r.PathValue("{{.PKURLParam}}"),
{{- range .ForeignKeys}}
		{{.FKGoName}}: r.PathValue("{{.FKURLParam}}"),
{{- end}}
	}
	return pp, nil
}

// orderByFields maps URL-friendly field names to repository OrderBy constants
var orderByFields = map[string]string{
	"{{.PKURLParam}}": {{.RepoPackage}}.OrderByPK,
	"created_at":      {{.RepoPackage}}.OrderByCreatedAt,
	"updated_at":      {{.RepoPackage}}.OrderByUpdatedAt,
{{- range .FilterFields}}
	"{{.DBColumn}}": {{$.RepoPackage}}.OrderBy{{.BridgeName}},
{{- end}}
}

// parseGeneratedOrderBy converts order query param to fop.By with validation
func parseGeneratedOrderBy(order string) fop.By {
	if order == "" {
		return {{.RepoPackage}}.DefaultOrderBy
	}

	// Use FOP's ParseOrder which handles "field,direction" format
	orderBy, err := fop.ParseOrder(orderByFields, order, {{.RepoPackage}}.DefaultOrderBy)
	if err != nil {
		return {{.RepoPackage}}.DefaultOrderBy
	}

	return orderBy
}

// ========================================
// GENERATED BRIDGE (HTTP HANDLERS)
// ========================================

// GeneratedBridge provides default HTTP handler implementations.
// Embed this in your custom bridge struct to inherit default handlers.
type GeneratedBridge struct {
	{{.EntityNameLower}}Repository {{.EntityName}}Repository
}

// {{.EntityName}}Repository defines the repository interface needed by bridge handlers
type {{.EntityName}}Repository interface {
	Create(ctx context.Context, input {{.RepoPackage}}.Create{{.EntityName}}) ({{.RepoPackage}}.{{.EntityName}}, error)
	Get(ctx context.Context, {{.PKParamName}} {{.PKGoType}}) ({{.RepoPackage}}.{{.EntityName}}, error)
	Update(ctx context.Context, {{.PKParamName}} {{.PKGoType}}, input {{.RepoPackage}}.Update{{.EntityName}}) error
	Delete(ctx context.Context, {{.PKParamName}} {{.PKGoType}}) error
	List(ctx context.Context, filter {{.RepoPackage}}.{{.EntityName}}Filter, orderBy fop.By, page fop.PageStringCursor) ([]{{.RepoPackage}}.{{.EntityName}}, fop.Pagination, error)
{{- range .ForeignKeys}}
	ListBy{{.FKGoName}}(ctx context.Context, {{.FKParamName}} {{.FKGoType}}, orderBy fop.By, page fop.PageStringCursor) ([]{{$.RepoPackage}}.{{$.EntityName}}, fop.Pagination, error)
{{- end}}
}

// ============================================================================
// SUGGESTED ROUTES FOR http.go
// ============================================================================
// Copy these routes to http.go's AddHttpRoutes function.
// If new foreign keys are added by migrations, new routes will appear here.
//
//	// Standard CRUD routes
//	group.GET("{{.HTTPBasePath}}", b.httpList)
//	group.GET("{{printf "%s/{%s}" .HTTPBasePath .PKURLParam}}", b.httpGetByID)
//	group.POST("{{.HTTPBasePath}}", b.httpCreate)
//	group.PUT("{{printf "%s/{%s}" .HTTPBasePath .PKURLParam}}", b.httpUpdate)
//	group.DELETE("{{printf "%s/{%s}" .HTTPBasePath .PKURLParam}}", b.httpDelete)
{{- if .ForeignKeys}}
//
//	// Foreign key routes
{{- range .ForeignKeys}}
//	group.GET("{{.RoutePath}}", b.{{.MethodName}})
{{- end}}
{{- end}}
// ============================================================================

// httpList handles GET requests for listing {{.EntityNamePlural}} with pagination and filtering
func (b *GeneratedBridge) httpList(ctx context.Context, r *http.Request) web.Encoder {
	qp := parseGeneratedQueryParams(r)

	page, err := fop.ParsePageStringCursor(qp.Limit, qp.Cursor)
	if err != nil {
		return errs.NewFieldErrors("page", err)
	}

	filter, err := parseGeneratedFilter(qp)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid filter: %s", err)
	}

	orderBy := parseGeneratedOrderBy(qp.Order)

	records, pagination, err := b.{{.EntityNameLower}}Repository.List(ctx, filter, orderBy, page)
	if err != nil {
		return errs.Newf(errs.Internal, "list {{.EntityNamePlural}}: %s", err)
	}

	return fopbridge.NewPaginatedResult(MarshalListToBridge(records), pagination)
}

// httpGetByID handles GET requests for retrieving a specific {{.EntityNameLower}} by ID
func (b *GeneratedBridge) httpGetByID(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parseGeneratedPath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	if qpath.{{.PKGoName}} == "" {
		return errs.Newf(errs.InvalidArgument, "{{.PKURLParam}} is required")
	}

	record, err := b.{{.EntityNameLower}}Repository.Get(ctx, qpath.{{.PKGoName}})
	if err != nil {
		return errs.Newf(errs.NotFound, "{{.EntityNameLower}} not found: %s", qpath.{{.PKGoName}})
	}

	return MarshalToBridge(record)
}

// httpCreate handles POST requests for creating a new {{.EntityNameLower}}
func (b *GeneratedBridge) httpCreate(ctx context.Context, r *http.Request) web.Encoder {
	var input GeneratedCreate{{.EntityName}}Input
	if err := web.Decode(r, &input); err != nil {
		return errs.Newf(errs.InvalidArgument, "decode: %s", err)
	}

	createInput := MarshalCreateToRepository(input)

	record, err := b.{{.EntityNameLower}}Repository.Create(ctx, createInput)
	if err != nil {
		return errs.Newf(errs.Internal, "create {{.EntityNameLower}}: %s", err)
	}

	return MarshalToBridge(record)
}

// httpUpdate handles PUT/PATCH requests for updating an existing {{.EntityNameLower}}
func (b *GeneratedBridge) httpUpdate(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parseGeneratedPath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	if qpath.{{.PKGoName}} == "" {
		return errs.Newf(errs.InvalidArgument, "{{.PKURLParam}} is required")
	}

	var input GeneratedUpdate{{.EntityName}}Input
	if err := web.Decode(r, &input); err != nil {
		return errs.Newf(errs.InvalidArgument, "decode: %s", err)
	}

	updateInput := MarshalUpdateToRepository(input)

	err = b.{{.EntityNameLower}}Repository.Update(ctx, qpath.{{.PKGoName}}, updateInput)
	if err != nil {
		return errs.Newf(errs.Internal, "update {{.EntityNameLower}}: %s", err)
	}

	return fopbridge.CodeResponse{
		Code:    errs.OK.String(),
		Message: "{{.EntityName}} updated successfully",
	}
}

// httpDelete handles DELETE requests for removing a {{.EntityNameLower}}
func (b *GeneratedBridge) httpDelete(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parseGeneratedPath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	if qpath.{{.PKGoName}} == "" {
		return errs.Newf(errs.InvalidArgument, "{{.PKURLParam}} is required")
	}

	err = b.{{.EntityNameLower}}Repository.Delete(ctx, qpath.{{.PKGoName}})
	if err != nil {
		return errs.Newf(errs.Internal, "delete {{.EntityNameLower}}: %s", err)
	}

	return fopbridge.CodeResponse{
		Code:    errs.OK.String(),
		Message: "{{.EntityName}} deleted successfully",
	}
}
{{- range .ForeignKeys}}

// {{.MethodName}} handles GET requests for listing {{$.EntityNamePlural}} by {{.RefEntityName}}
func (b *GeneratedBridge) {{.MethodName}}(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parseGeneratedPath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	if qpath.{{.FKGoName}} == "" {
		return errs.Newf(errs.InvalidArgument, "{{.FKURLParam}} is required")
	}

	qp := parseGeneratedQueryParams(r)

	page, err := fop.ParsePageStringCursor(qp.Limit, qp.Cursor)
	if err != nil {
		return errs.NewFieldErrors("page", err)
	}

	orderBy := parseGeneratedOrderBy(qp.Order)

	records, pagination, err := b.{{$.EntityNameLower}}Repository.ListBy{{.FKGoName}}(ctx, qpath.{{.FKGoName}}, orderBy, page)
	if err != nil {
		return errs.Newf(errs.Internal, "list {{$.EntityNamePlural}} by {{.FKGoName}}: %s", err)
	}

	return fopbridge.NewPaginatedResult(MarshalListToBridge(records), pagination)
}
{{- end}}
`
