package pgxstores

const StoreTemplate = `// Code generated by pgxstores. DO NOT EDIT.

package {{.PackageName}}

import (
	"bytes"
	"context"
	"errors"
	"fmt"
{{- if .NeedsTime}}
	"time"
{{- end}}
{{- if .NeedsJSON}}
	"encoding/json"
{{- end}}

	"github.com/jackc/pgx/v5"
	"{{.ModulePath}}/core/repositories/{{.RepoPackage}}"
	"{{.ModulePath}}/sdk/fop"
	"{{.ModulePath}}/infrastructure/postgresdb"
)

// Create inserts a new {{.Entity}}
func (s *{{.StoreType}}) Create(ctx context.Context, input {{.RepoPackage}}.{{.Create}}) ({{.RepoPackage}}.{{.Entity}}, error) {
	{{- if .PKInCreate}}
	// PK is in Create struct - use value from input
	query := ` + "`INSERT INTO {{.Schema}}.{{.Table}} ({{range $i, $f := .CreateFields}}{{if $i}}, {{end}}{{$f.DBColumn}}{{end}}) VALUES ({{range $i, $f := .CreateFields}}{{if $i}}, {{end}}@{{$f.DBColumn}}{{end}}) RETURNING {{range $i, $f := .EntityFields}}{{if $i}}, {{end}}{{$f.DBColumn}}{{end}}`" + `
	{{- else}}
	// PK not in Create struct - let database generate it
	query := ` + "`INSERT INTO {{.Schema}}.{{.Table}} ({{range $i, $f := .CreateFields}}{{if $i}}, {{end}}{{$f.DBColumn}}{{end}}) VALUES ({{range $i, $f := .CreateFields}}{{if $i}}, {{end}}@{{$f.DBColumn}}{{end}}) RETURNING {{range $i, $f := .EntityFields}}{{if $i}}, {{end}}{{$f.DBColumn}}{{end}}`" + `
	{{- end}}

	args := pgx.NamedArgs{
{{- range .CreateFields}}
		"{{.DBColumn}}": input.{{.Name}},
{{- end}}
	}

	rows, err := s.pool.Query(ctx, query, args)
	if err != nil {
		return {{.RepoPackage}}.{{.Entity}}{}, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	record, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[{{.RepoPackage}}.{{.Entity}}])
	if err != nil {
		return {{.RepoPackage}}.{{.Entity}}{}, postgresdb.HandlePgError(err)
	}

	return record, nil
}

// Get retrieves a single {{.Entity}} by ID
func (s *{{.StoreType}}) Get(ctx context.Context, {{.PK}} {{.PKGoType}}) ({{.RepoPackage}}.{{.Entity}}, error) {
	query := ` + "`SELECT {{range $i, $f := .EntityFields}}{{if $i}}, {{end}}{{$f.DBColumn}}{{end}} FROM {{.Schema}}.{{.Table}} WHERE {{.PK}} = @{{.PK}}`" + `

	args := pgx.NamedArgs{
		"{{.PK}}": {{.PK}},
	}

	rows, err := s.pool.Query(ctx, query, args)
	if err != nil {
		return {{.RepoPackage}}.{{.Entity}}{}, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	record, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[{{.RepoPackage}}.{{.Entity}}])
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return {{.RepoPackage}}.{{.Entity}}{}, fmt.Errorf("{{.Entity}} not found")
		}
		return {{.RepoPackage}}.{{.Entity}}{}, postgresdb.HandlePgError(err)
	}

	return record, nil
}

// Update modifies an existing {{.Entity}}
func (s *{{.StoreType}}) Update(ctx context.Context, {{.PK}} {{.PKGoType}}, input {{.RepoPackage}}.{{.Update}}) ({{.RepoPackage}}.{{.Entity}}, error) {
	var updates []string
	args := pgx.NamedArgs{
		"{{.PK}}": {{.PK}},
	}

{{- range .UpdateFields}}
	if input.{{.Name}} != nil {
		updates = append(updates, "{{.DBColumn}} = @{{.DBColumn}}")
		args["{{.DBColumn}}"] = input.{{.Name}}
	}
{{- end}}

	if len(updates) == 0 {
		return s.Get(ctx, {{.PK}})
	}

	query := fmt.Sprintf(` + "`UPDATE {{.Schema}}.{{.Table}} SET %s WHERE {{.PK}} = @{{.PK}} RETURNING {{range $i, $f := .EntityFields}}{{if $i}}, {{end}}{{$f.DBColumn}}{{end}}`" + `, strings.Join(updates, ", "))

	rows, err := s.pool.Query(ctx, query, args)
	if err != nil {
		return {{.RepoPackage}}.{{.Entity}}{}, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	record, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[{{.RepoPackage}}.{{.Entity}}])
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return {{.RepoPackage}}.{{.Entity}}{}, fmt.Errorf("{{.Entity}} not found")
		}
		return {{.RepoPackage}}.{{.Entity}}{}, postgresdb.HandlePgError(err)
	}

	return record, nil
}

// Delete removes a {{.Entity}} by ID
func (s *{{.StoreType}}) Delete(ctx context.Context, {{.PK}} {{.PKGoType}}) error {
	query := ` + "`DELETE FROM {{.Schema}}.{{.Table}} WHERE {{.PK}} = @{{.PK}}`" + `

	args := pgx.NamedArgs{
		"{{.PK}}": {{.PK}},
	}

	result, err := s.pool.Exec(ctx, query, args)
	if err != nil {
		return postgresdb.HandlePgError(err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("{{.Entity}} not found")
	}

	return nil
}

// List retrieves {{.Entity}} records with filters, ordering, and pagination
func (s *{{.StoreType}}) List(ctx context.Context, filter {{.RepoPackage}}.{{.Filter}}, fop fop.FOP) ([]{{.RepoPackage}}.{{.Entity}}, *fop.Pagination, error) {
	var queryBuilder bytes.Buffer
	args := pgx.NamedArgs{}

	// Base query
	queryBuilder.WriteString(` + "`SELECT {{range $i, $f := .EntityFields}}{{if $i}}, {{end}}{{$f.DBColumn}}{{end}} FROM {{.Schema}}.{{.Table}}`" + `)

	// WHERE clause
	var conditions []string
{{- range .FilterFields}}
	if filter.{{.Name}} != nil {
		conditions = append(conditions, "{{.DBColumn}} = @filter_{{.DBColumn}}")
		args["filter_{{.DBColumn}}"] = filter.{{.Name}}
	}
{{- end}}

	if len(conditions) > 0 {
		queryBuilder.WriteString(" WHERE ")
		queryBuilder.WriteString(strings.Join(conditions, " AND "))
	}

	// ORDER BY
	orderBy := fop.Order
	if orderBy == "" {
		orderBy = "{{.PK}}"
	}
	orderDir := "ASC"
	if fop.Desc {
		orderDir = "DESC"
	}
	queryBuilder.WriteString(fmt.Sprintf(" ORDER BY %s %s", orderBy, orderDir))

	// Cursor-based pagination
	cursorConfig := fop.PageStringCursor{
		After:     fop.After,
		Before:    fop.Before,
		Limit:     fop.Limit,
		OrderBy:   orderBy,
		Descending: fop.Desc,
	}

	if cursorConfig.After != "" {
		if fop.Desc {
			queryBuilder.WriteString(fmt.Sprintf(" AND %s < @cursor", orderBy))
		} else {
			queryBuilder.WriteString(fmt.Sprintf(" AND %s > @cursor", orderBy))
		}
		args["cursor"] = cursorConfig.After
	} else if cursorConfig.Before != "" {
		if fop.Desc {
			queryBuilder.WriteString(fmt.Sprintf(" AND %s > @cursor", orderBy))
		} else {
			queryBuilder.WriteString(fmt.Sprintf(" AND %s < @cursor", orderBy))
		}
		args["cursor"] = cursorConfig.Before
		// Reverse order for "before" pagination
		if orderDir == "ASC" {
			orderDir = "DESC"
		} else {
			orderDir = "ASC"
		}
		queryBuilder.WriteString(fmt.Sprintf(" ORDER BY %s %s", orderBy, orderDir))
	}

	// LIMIT
	limit := fop.Limit
	if limit == 0 {
		limit = 20
	}
	queryBuilder.WriteString(" LIMIT @limit")
	args["limit"] = limit + 1 // Fetch one extra to check if there are more

	// Execute query
	rows, err := s.pool.Query(ctx, queryBuilder.String(), args)
	if err != nil {
		return nil, nil, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	records, err := pgx.CollectRows(rows, pgx.RowToStructByName[{{.RepoPackage}}.{{.Entity}}])
	if err != nil {
		return nil, nil, postgresdb.HandlePgError(err)
	}

	// Build pagination info
	hasMore := len(records) > limit
	if hasMore {
		records = records[:limit]
	}

	// If we used "before", reverse the results back
	if cursorConfig.Before != "" {
		for i, j := 0, len(records)-1; i < j; i, j = i+1, j-1 {
			records[i], records[j] = records[j], records[i]
		}
	}

	pagination := &fop.Pagination{
		Limit:   limit,
		HasMore: hasMore,
	}

	if len(records) > 0 {
		// Set cursors based on order
		// For now, using {{.PK}} as cursor - this should be extracted from the actual orderBy field
		// This is a simplified implementation
		pagination.StartCursor = fmt.Sprintf("%v", records[0].{{.PKGoName}})
		pagination.EndCursor = fmt.Sprintf("%v", records[len(records)-1].{{.PKGoName}})
	}

	return records, pagination, nil
}
{{- range .ForeignKeys}}

// {{.MethodName}} retrieves all {{$.Entity}} records for a given foreign key
func (s *{{$.StoreType}}) {{.MethodName}}(ctx context.Context, {{.FKParamName}} {{.FKGoType}}, fop fop.FOP) ([]{{$.RepoPackage}}.{{$.Entity}}, *fop.Pagination, error) {
	var queryBuilder bytes.Buffer
	args := pgx.NamedArgs{
		"{{.FKColumn}}": {{.FKParamName}},
	}

	// Base query with FK filter
	queryBuilder.WriteString(` + "`SELECT {{range $i, $f := $.EntityFields}}{{if $i}}, {{end}}{{$f.DBColumn}}{{end}} FROM {{$.Schema}}.{{$.Table}} WHERE {{.FKColumn}} = @{{.FKColumn}}`" + `)

	// ORDER BY
	orderBy := fop.Order
	if orderBy == "" {
		orderBy = "{{$.PK}}"
	}
	orderDir := "ASC"
	if fop.Desc {
		orderDir = "DESC"
	}
	queryBuilder.WriteString(fmt.Sprintf(" ORDER BY %s %s", orderBy, orderDir))

	// Cursor pagination
	cursorConfig := fop.PageStringCursor{
		After:      fop.After,
		Before:     fop.Before,
		Limit:      fop.Limit,
		OrderBy:    orderBy,
		Descending: fop.Desc,
	}

	if cursorConfig.After != "" {
		if fop.Desc {
			queryBuilder.WriteString(fmt.Sprintf(" AND %s < @cursor", orderBy))
		} else {
			queryBuilder.WriteString(fmt.Sprintf(" AND %s > @cursor", orderBy))
		}
		args["cursor"] = cursorConfig.After
	} else if cursorConfig.Before != "" {
		if fop.Desc {
			queryBuilder.WriteString(fmt.Sprintf(" AND %s > @cursor", orderBy))
		} else {
			queryBuilder.WriteString(fmt.Sprintf(" AND %s < @cursor", orderBy))
		}
		args["cursor"] = cursorConfig.Before
	}

	// LIMIT
	limit := fop.Limit
	if limit == 0 {
		limit = 20
	}
	queryBuilder.WriteString(" LIMIT @limit")
	args["limit"] = limit + 1

	// Execute query
	rows, err := s.pool.Query(ctx, queryBuilder.String(), args)
	if err != nil {
		return nil, nil, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	records, err := pgx.CollectRows(rows, pgx.RowToStructByName[{{$.RepoPackage}}.{{$.Entity}}])
	if err != nil {
		return nil, nil, postgresdb.HandlePgError(err)
	}

	// Build pagination
	hasMore := len(records) > limit
	if hasMore {
		records = records[:limit]
	}

	if cursorConfig.Before != "" {
		for i, j := 0, len(records)-1; i < j; i, j = i+1, j-1 {
			records[i], records[j] = records[j], records[i]
		}
	}

	pagination := &fop.Pagination{
		Limit:   limit,
		HasMore: hasMore,
	}

	if len(records) > 0 {
		pagination.StartCursor = fmt.Sprintf("%v", records[0].{{$.PKGoName}})
		pagination.EndCursor = fmt.Sprintf("%v", records[len(records)-1].{{$.PKGoName}})
	}

	return records, pagination, nil
}
{{- end}}
`
