package bridgegen

const HTTPTemplate = `// Code generated by bridgegen. DO NOT EDIT.

package {{.PackageName}}

import (
	"context"
	"net/http"

	"{{.ModulePath}}/bridge/scaffolding/errs"
	"{{.ModulePath}}/bridge/scaffolding/fopbridge"
	"{{.ModulePath}}/core/repositories/{{.RepoPackage}}"
	"{{.ModulePath}}/core/scaffolding/fop"
	"{{.ModulePath}}/infrastructure/web"
	"{{.ModulePath}}/sdk/logger"
)

type Config struct {
	Log        *logger.Logger
	Repository *{{.RepoPackage}}.Repository
	Middleware []web.Middleware
}

func AddHttpRoutes(group *web.RouteGroup, cfg Config) {
	b := newBridge(cfg.Repository)

	// Standard CRUD routes
	group.GET("{{.HTTPBasePath}}", b.httpList)
	group.GET("{{.HTTPBasePath}}/{{"{{"}}.{{.PKURLParam}}{{"}}"}}", b.httpGetByID)
	group.POST("{{.HTTPBasePath}}", b.httpCreate)
	group.PUT("{{.HTTPBasePath}}/{{"{{"}}.{{.PKURLParam}}{{"}}"}}", b.httpUpdate)
	group.DELETE("{{.HTTPBasePath}}/{{"{{"}}.{{.PKURLParam}}{{"}}"}}", b.httpDelete)
{{- range .ForeignKeys}}

	// Foreign key route: {{.MethodName}}
	group.GET("{{.RoutePath}}", b.{{.MethodName}})
{{- end}}
}

// httpList handles GET requests for listing {{.EntityNamePlural}} with pagination and filtering
func (b *bridge) httpList(ctx context.Context, r *http.Request) web.Encoder {
	qp := parseQueryParams(r)

	page, err := fop.ParsePageStringCursor(qp.Limit, qp.Cursor)
	if err != nil {
		return errs.NewFieldErrors("page", err)
	}

	filter := MarshalFilterToRepository(parseFilter(qp))
	orderBy := parseOrderBy(qp.Order)

	records, pageInfo, err := b.{{.EntityNameLower}}Repository.List(ctx, filter, orderBy, page)
	if err != nil {
		return errs.Newf(errs.Internal, "list {{.EntityNamePlural}}: %s", err)
	}

	return fopbridge.NewPaginatedResultStringCursor(MarshalListToBridge(records), pageInfo)
}

// httpGetByID handles GET requests for retrieving a specific {{.EntityNameLower}} by ID
func (b *bridge) httpGetByID(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parsePath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	if qpath.{{.PKGoName}} == "" {
		return errs.Newf(errs.InvalidArgument, "{{.PKURLParam}} is required")
	}

	record, err := b.{{.EntityNameLower}}Repository.Get(ctx, qpath.{{.PKGoName}})
	if err != nil {
		return errs.Newf(errs.NotFound, "{{.EntityNameLower}} not found: %s", qpath.{{.PKGoName}})
	}

	return MarshalToBridge(record)
}

// httpCreate handles POST requests for creating a new {{.EntityNameLower}}
func (b *bridge) httpCreate(ctx context.Context, r *http.Request) web.Encoder {
	var input Create{{.EntityName}}Input
	if err := web.Decode(r, &input); err != nil {
		return errs.Newf(errs.InvalidArgument, "decode: %s", err)
	}

	createInput := MarshalCreateToRepository(input)

	record, err := b.{{.EntityNameLower}}Repository.Create(ctx, createInput)
	if err != nil {
		return errs.Newf(errs.Internal, "create {{.EntityNameLower}}: %s", err)
	}

	return MarshalToBridge(record)
}

// httpUpdate handles PUT/PATCH requests for updating an existing {{.EntityNameLower}}
func (b *bridge) httpUpdate(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parsePath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	if qpath.{{.PKGoName}} == "" {
		return errs.Newf(errs.InvalidArgument, "{{.PKURLParam}} is required")
	}

	var input Update{{.EntityName}}Input
	if err := web.Decode(r, &input); err != nil {
		return errs.Newf(errs.InvalidArgument, "decode: %s", err)
	}

	updateInput := MarshalUpdateToRepository(input)

	record, err := b.{{.EntityNameLower}}Repository.Update(ctx, qpath.{{.PKGoName}}, updateInput)
	if err != nil {
		return errs.Newf(errs.Internal, "update {{.EntityNameLower}}: %s", err)
	}

	return MarshalToBridge(record)
}

// httpDelete handles DELETE requests for removing a {{.EntityNameLower}}
func (b *bridge) httpDelete(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parsePath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	if qpath.{{.PKGoName}} == "" {
		return errs.Newf(errs.InvalidArgument, "{{.PKURLParam}} is required")
	}

	err = b.{{.EntityNameLower}}Repository.Delete(ctx, qpath.{{.PKGoName}})
	if err != nil {
		return errs.Newf(errs.Internal, "delete {{.EntityNameLower}}: %s", err)
	}

	return fopbridge.CodeResponse{
		Code:    errs.OK.String(),
		Message: "{{.EntityName}} deleted successfully",
	}
}
{{- range .ForeignKeys}}

// {{.MethodName}} handles GET requests for listing {{$.EntityNamePlural}} by {{.RefEntityName}}
func (b *bridge) {{.MethodName}}(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parsePath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	if qpath.{{.FKGoName}} == "" {
		return errs.Newf(errs.InvalidArgument, "{{.FKURLParam}} is required")
	}

	qp := parseQueryParams(r)

	page, err := fop.ParsePageStringCursor(qp.Limit, qp.Cursor)
	if err != nil {
		return errs.NewFieldErrors("page", err)
	}

	orderBy := parseOrderBy(qp.Order)

	records, pageInfo, err := b.{{$.EntityNameLower}}Repository.List{{.FKGoName}}(ctx, qpath.{{.FKGoName}}, orderBy, page)
	if err != nil {
		return errs.Newf(errs.Internal, "list {{$.EntityNamePlural}} by {{.FKGoName}}: %s", err)
	}

	return fopbridge.NewPaginatedResultStringCursor(MarshalListToBridge(records), pageInfo)
}
{{- end}}
`
