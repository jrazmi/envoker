// Code generated by pgxstores. DO NOT EDIT.
// This file is ALWAYS REGENERATED - do not modify.
// For custom queries, see store.go which embeds the generated store.

package usersessionspgxstore

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/jrazmi/envoker/core/repositories/usersessionsrepo"
	"github.com/jrazmi/envoker/core/scaffolding/fop"
	"github.com/jrazmi/envoker/infrastructure/postgresdb"
	"github.com/jrazmi/envoker/sdk/logger"
)

// ========================================
// GENERATED STORE
// ========================================

// GeneratedStore provides default implementations for all UserSession SQL operations.
// Embed this struct in your custom Store (in store.go) to inherit default behavior
// that you can selectively override.
type GeneratedStore struct {
	log  *logger.Logger
	pool *postgresdb.Pool
}

// Create inserts a new UserSession
func (s *GeneratedStore) Create(ctx context.Context, input usersessionsrepo.CreateUserSession) (usersessionsrepo.UserSession, error) {
	// PK not in Create struct - let database generate it
	query := `INSERT INTO public.user_sessions (user_id, session_token, refresh_token, ip_address, user_agent, device_info, expires_at, refresh_expires_at, status, last_active_at) VALUES (@user_id, @session_token, @refresh_token, @ip_address, @user_agent, @device_info, @expires_at, @refresh_expires_at, @status, @last_active_at) RETURNING session_id, user_id, session_token, refresh_token, ip_address, user_agent, device_info, expires_at, refresh_expires_at, status, created_at, updated_at, last_active_at`

	args := pgx.NamedArgs{
		"user_id":            input.UserId,
		"session_token":      input.SessionToken,
		"refresh_token":      input.RefreshToken,
		"ip_address":         input.IpAddress,
		"user_agent":         input.UserAgent,
		"device_info":        input.DeviceInfo,
		"expires_at":         input.ExpiresAt,
		"refresh_expires_at": input.RefreshExpiresAt,
		"status":             input.Status,
		"last_active_at":     input.LastActiveAt,
	}

	rows, err := s.pool.Query(ctx, query, args)
	if err != nil {
		return usersessionsrepo.UserSession{}, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	record, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[usersessionsrepo.UserSession])
	if err != nil {
		return usersessionsrepo.UserSession{}, postgresdb.HandlePgError(err)
	}

	return record, nil
}

// Get retrieves a single UserSession by ID
func (s *GeneratedStore) Get(ctx context.Context, sessionId string) (usersessionsrepo.UserSession, error) {
	query := `SELECT session_id, user_id, session_token, refresh_token, ip_address, user_agent, device_info, expires_at, refresh_expires_at, status, created_at, updated_at, last_active_at FROM public.user_sessions WHERE session_id = @sessionId`

	args := pgx.NamedArgs{
		"sessionId": sessionId,
	}

	rows, err := s.pool.Query(ctx, query, args)
	if err != nil {
		return usersessionsrepo.UserSession{}, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	record, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[usersessionsrepo.UserSession])
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return usersessionsrepo.UserSession{}, fmt.Errorf("UserSession not found")
		}
		return usersessionsrepo.UserSession{}, postgresdb.HandlePgError(err)
	}

	return record, nil
}

// Update modifies an existing UserSession
func (s *GeneratedStore) Update(ctx context.Context, sessionId string, input usersessionsrepo.UpdateUserSession) error {
	buf := bytes.NewBufferString("UPDATE public.user_sessions SET ")
	args := pgx.NamedArgs{
		"sessionId": sessionId,
	}
	var fields []string
	if input.UserId != nil {
		fields = append(fields, "user_id = @user_id")
		args["user_id"] = *input.UserId
	}
	if input.SessionToken != nil {
		fields = append(fields, "session_token = @session_token")
		args["session_token"] = *input.SessionToken
	}
	if input.RefreshToken != nil {
		fields = append(fields, "refresh_token = @refresh_token")
		args["refresh_token"] = *input.RefreshToken
	}
	if input.IpAddress != nil {
		fields = append(fields, "ip_address = @ip_address")
		args["ip_address"] = *input.IpAddress
	}
	if input.UserAgent != nil {
		fields = append(fields, "user_agent = @user_agent")
		args["user_agent"] = *input.UserAgent
	}
	if input.DeviceInfo != nil {
		fields = append(fields, "device_info = @device_info")
		args["device_info"] = *input.DeviceInfo
	}
	if input.ExpiresAt != nil {
		fields = append(fields, "expires_at = @expires_at")
		args["expires_at"] = *input.ExpiresAt
	}
	if input.RefreshExpiresAt != nil {
		fields = append(fields, "refresh_expires_at = @refresh_expires_at")
		args["refresh_expires_at"] = *input.RefreshExpiresAt
	}
	if input.Status != nil {
		fields = append(fields, "status = @status")
		args["status"] = *input.Status
	}
	if input.LastActiveAt != nil {
		fields = append(fields, "last_active_at = @last_active_at")
		args["last_active_at"] = *input.LastActiveAt
	}

	// Always update the updated_at field
	now := time.Now().UTC()
	if input.UpdatedAt != nil {
		args["updated_at"] = *input.UpdatedAt
	} else {
		args["updated_at"] = now
	}
	fields = append(fields, "updated_at = @updated_at")

	// If no fields to update besides updated_at, return early
	if len(fields) == 1 {
		return fmt.Errorf("no fields to update")
	}

	// Join fields and complete the query
	buf.WriteString(strings.Join(fields, ", "))
	buf.WriteString(" WHERE session_id = @sessionId")

	query := buf.String()
	s.log.DebugContext(ctx, "update UserSession", "query", query, "sessionId", sessionId)

	result, err := s.pool.Exec(ctx, query, args)
	if err != nil {
		return postgresdb.HandlePgError(err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("UserSession not found")
	}

	return nil
}

// Delete removes a UserSession by ID
func (s *GeneratedStore) Delete(ctx context.Context, sessionId string) error {
	query := `DELETE FROM public.user_sessions WHERE session_id = @sessionId`

	args := pgx.NamedArgs{
		"sessionId": sessionId,
	}

	result, err := s.pool.Exec(ctx, query, args)
	if err != nil {
		return postgresdb.HandlePgError(err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("UserSession not found")
	}

	return nil
}

// List retrieves UserSession records with filtering, ordering, and cursor pagination
func (s *GeneratedStore) List(ctx context.Context, filter usersessionsrepo.UserSessionFilter, orderBy fop.By, page fop.PageStringCursor, forPrevious bool) ([]usersessionsrepo.UserSession, error) {
	data := pgx.NamedArgs{}

	// Start building the query
	buf := bytes.NewBufferString(`
		SELECT
			session_id,
			user_id,
			session_token,
			refresh_token,
			ip_address,
			user_agent,
			device_info,
			expires_at,
			refresh_expires_at,
			status,
			created_at,
			updated_at,
			last_active_at
		FROM
			public.user_sessions`)

	// Apply filters
	s.applyFilter(filter, data, buf)

	// Setup configuration for string cursor pagination
	cursorConfig := postgresdb.StringCursorConfig{
		Cursor:     page.Cursor,
		OrderField: orderByFields[orderBy.Field],
		PKField:    "session_id",
		TableName:  "user_sessions",
		Direction:  orderBy.Direction,
		Limit:      page.Limit,
	}

	// Apply cursor pagination
	if page.Cursor != "" {
		err := postgresdb.ApplyStringCursorPagination[time.Time](buf, data, cursorConfig, forPrevious)
		if err != nil {
			return nil, fmt.Errorf("cursorpagination: %s", err)
		}
	}

	// Add ordering
	err := postgresdb.AddOrderByClause(buf, cursorConfig.OrderField, cursorConfig.PKField, cursorConfig.Direction, forPrevious)
	if err != nil {
		return nil, fmt.Errorf("order: %w", err)
	}

	// Add limit
	postgresdb.AddLimitClause(cursorConfig.Limit, data, buf)

	// Execute the query
	query := buf.String()
	s.log.DebugContext(ctx, "list UserSession", "query", query)

	rows, err := s.pool.Query(ctx, query, data)
	if err != nil {
		return nil, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	entities, err := pgx.CollectRows(rows, pgx.RowToStructByName[usersessionsrepo.UserSession])
	if err != nil {
		return nil, postgresdb.HandlePgError(err)
	}

	// If we were getting previous page, reverse the results back to correct order
	if forPrevious && len(entities) > 0 {
		for i, j := 0, len(entities)-1; i < j; i, j = i+1, j-1 {
			entities[i], entities[j] = entities[j], entities[i]
		}
	}

	return entities, nil
}

// Archive sets the status to 'archived'
func (s *GeneratedStore) Archive(ctx context.Context, sessionId string) error {
	data := pgx.NamedArgs{
		"sessionId": sessionId,
		"status":    "archived",
	}

	query := `UPDATE public.user_sessions SET status = @status`

	query += ` WHERE session_id = @sessionId`

	result, err := s.pool.Exec(ctx, query, data)
	if err != nil {
		return postgresdb.HandlePgError(err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("UserSession not found")
	}

	return nil
}

// ListByUserId retrieves UserSession records by foreign key with cursor pagination
func (s *GeneratedStore) ListByUserId(ctx context.Context, userId string, orderBy fop.By, page fop.PageStringCursor, forPrevious bool) ([]usersessionsrepo.UserSession, error) {
	data := pgx.NamedArgs{
		"userId": userId,
	}

	// Start building the query
	buf := bytes.NewBufferString(`
		SELECT
			session_id,
			user_id,
			session_token,
			refresh_token,
			ip_address,
			user_agent,
			device_info,
			expires_at,
			refresh_expires_at,
			status,
			created_at,
			updated_at,
			last_active_at
		FROM
			public.user_sessions
		WHERE
			user_id = @userId`)

	// Setup configuration for string cursor pagination
	cursorConfig := postgresdb.StringCursorConfig{
		Cursor:     page.Cursor,
		OrderField: orderByFields[orderBy.Field],
		PKField:    "session_id",
		TableName:  "user_sessions",
		Direction:  orderBy.Direction,
		Limit:      page.Limit,
	}

	// Apply cursor pagination
	if page.Cursor != "" {
		err := postgresdb.ApplyStringCursorPagination[time.Time](buf, data, cursorConfig, forPrevious)
		if err != nil {
			return nil, fmt.Errorf("cursorpagination: %s", err)
		}
	}

	// Add ordering
	err := postgresdb.AddOrderByClause(buf, cursorConfig.OrderField, cursorConfig.PKField, cursorConfig.Direction, forPrevious)
	if err != nil {
		return nil, fmt.Errorf("order: %w", err)
	}

	// Add limit
	postgresdb.AddLimitClause(cursorConfig.Limit, data, buf)

	// Execute the query
	query := buf.String()
	s.log.DebugContext(ctx, "ListByUserId", "query", query, "userId", userId)

	rows, err := s.pool.Query(ctx, query, data)
	if err != nil {
		return nil, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	entities, err := pgx.CollectRows(rows, pgx.RowToStructByName[usersessionsrepo.UserSession])
	if err != nil {
		return nil, postgresdb.HandlePgError(err)
	}

	// If we were getting previous page, reverse the results back to correct order
	if forPrevious && len(entities) > 0 {
		for i, j := 0, len(entities)-1; i < j; i, j = i+1, j-1 {
			entities[i], entities[j] = entities[j], entities[i]
		}
	}

	return entities, nil
}

// ========================================
// FILTER & ORDERING HELPERS
// ========================================

// orderByFields maps repository field names to database column names
var orderByFields = map[string]string{
	usersessionsrepo.OrderByPK:               "session_id",
	usersessionsrepo.OrderByCreatedAt:        "created_at",
	usersessionsrepo.OrderByUpdatedAt:        "updated_at",
	usersessionsrepo.OrderByUserId:           "user_id",
	usersessionsrepo.OrderBySessionToken:     "session_token",
	usersessionsrepo.OrderByRefreshToken:     "refresh_token",
	usersessionsrepo.OrderByIpAddress:        "ip_address",
	usersessionsrepo.OrderByUserAgent:        "user_agent",
	usersessionsrepo.OrderByDeviceInfo:       "device_info",
	usersessionsrepo.OrderByExpiresAt:        "expires_at",
	usersessionsrepo.OrderByRefreshExpiresAt: "refresh_expires_at",
	usersessionsrepo.OrderByStatus:           "status",
	usersessionsrepo.OrderByLastActiveAt:     "last_active_at",
}

// applyFilter applies query filters to the SQL query
func (s *GeneratedStore) applyFilter(filter usersessionsrepo.UserSessionFilter, data pgx.NamedArgs, buf *bytes.Buffer) {
	var conditions []string
	// Filter by user_id
	if filter.UserId != nil {
		conditions = append(conditions, "user_id = @userId")
		data["userId"] = *filter.UserId
	}
	// Filter by session_token
	if filter.SessionToken != nil {
		conditions = append(conditions, "session_token = @sessionToken")
		data["sessionToken"] = *filter.SessionToken
	}
	// Filter by refresh_token
	if filter.RefreshToken != nil {
		conditions = append(conditions, "refresh_token = @refreshToken")
		data["refreshToken"] = *filter.RefreshToken
	}
	// Filter by ip_address
	if filter.IpAddress != nil {
		conditions = append(conditions, "ip_address = @ipAddress")
		data["ipAddress"] = *filter.IpAddress
	}
	// Filter by user_agent
	if filter.UserAgent != nil {
		conditions = append(conditions, "user_agent = @userAgent")
		data["userAgent"] = *filter.UserAgent
	}
	// Filter by expires_at
	if filter.ExpiresAt != nil {
		conditions = append(conditions, "expires_at = @expiresAt")
		data["expiresAt"] = *filter.ExpiresAt
	}
	// Filter by refresh_expires_at
	if filter.RefreshExpiresAt != nil {
		conditions = append(conditions, "refresh_expires_at = @refreshExpiresAt")
		data["refreshExpiresAt"] = *filter.RefreshExpiresAt
	}
	// Filter by status
	if filter.Status != nil {
		conditions = append(conditions, "status = @status")
		data["status"] = *filter.Status
	}
	// Filter by created_at - before
	if filter.CreatedAtBefore != nil {
		conditions = append(conditions, "created_at < @createdAt_before")
		data["createdAt_before"] = *filter.CreatedAtBefore
	}

	// Filter by created_at - after
	if filter.CreatedAtAfter != nil {
		conditions = append(conditions, "created_at > @createdAt_after")
		data["createdAt_after"] = *filter.CreatedAtAfter
	}
	// Filter by updated_at - before
	if filter.UpdatedAtBefore != nil {
		conditions = append(conditions, "updated_at < @updatedAt_before")
		data["updatedAt_before"] = *filter.UpdatedAtBefore
	}

	// Filter by updated_at - after
	if filter.UpdatedAtAfter != nil {
		conditions = append(conditions, "updated_at > @updatedAt_after")
		data["updatedAt_after"] = *filter.UpdatedAtAfter
	}
	// Filter by last_active_at
	if filter.LastActiveAt != nil {
		conditions = append(conditions, "last_active_at = @lastActiveAt")
		data["lastActiveAt"] = *filter.LastActiveAt
	}

	// Search term across text fields
	if filter.SearchTerm != nil && *filter.SearchTerm != "" {
		searchPattern := "%" + *filter.SearchTerm + "%"
		searchConditions := []string{}
		searchConditions = append(searchConditions, "session_token ILIKE @search_term")
		searchConditions = append(searchConditions, "refresh_token ILIKE @search_term")
		searchConditions = append(searchConditions, "user_agent ILIKE @search_term")
		searchConditions = append(searchConditions, "status ILIKE @search_term")
		if len(searchConditions) > 0 {
			conditions = append(conditions, "("+strings.Join(searchConditions, " OR ")+")")
			data["search_term"] = searchPattern
		}
	}

	// Apply conditions if any exist
	if len(conditions) > 0 {
		buf.WriteString(" WHERE ")
		buf.WriteString(strings.Join(conditions, " AND "))
	}
}
