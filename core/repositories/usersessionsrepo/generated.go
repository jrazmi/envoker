// Code generated by repositorygen. DO NOT EDIT.
// This file is ALWAYS REGENERATED - do not modify.
// For customizations, see repository.go which embeds the generated types.

package usersessionsrepo

import (
	"context"
	"fmt"

	"encoding/json"
	"time"

	"github.com/jrazmi/envoker/core/scaffolding/fop"
	"github.com/jrazmi/envoker/sdk/logger"
)

// ========================================
// MODELS
// ========================================

// GeneratedUserSession represents a userSession entity from the database.
// Use the type alias in repository.go to reference this type, or embed it to extend.
type GeneratedUserSession struct {
	SessionId        string           `json:"session_id" db:"session_id" validate:"required,uuid"`
	UserId           string           `json:"user_id" db:"user_id" validate:"required,uuid"`
	SessionToken     string           `json:"session_token" db:"session_token" validate:"required,max=255"`
	RefreshToken     *string          `json:"refresh_token" db:"refresh_token" validate:"max=255"`
	IpAddress        *string          `json:"ip_address" db:"ip_address"`
	UserAgent        *string          `json:"user_agent" db:"user_agent"`
	DeviceInfo       *json.RawMessage `json:"device_info" db:"device_info"`
	ExpiresAt        time.Time        `json:"expires_at" db:"expires_at" validate:"required"`
	RefreshExpiresAt *time.Time       `json:"refresh_expires_at" db:"refresh_expires_at"`
	Status           string           `json:"status" db:"status" validate:"required,max=50"`
	CreatedAt        time.Time        `json:"created_at" db:"created_at" validate:"required"`
	UpdatedAt        time.Time        `json:"updated_at" db:"updated_at" validate:"required"`
	LastActiveAt     time.Time        `json:"last_active_at" db:"last_active_at" validate:"required"`
}

// GeneratedCreateUserSession contains the data needed to create a new userSession.
// Use the type alias in repository.go to reference this type, or embed it to add custom fields.
type GeneratedCreateUserSession struct {
	UserId           string           `json:"user_id" db:"user_id" validate:"required,uuid"`
	SessionToken     string           `json:"session_token" db:"session_token" validate:"required,max=255"`
	RefreshToken     *string          `json:"refresh_token" db:"refresh_token" validate:"max=255"`
	IpAddress        *string          `json:"ip_address" db:"ip_address"`
	UserAgent        *string          `json:"user_agent" db:"user_agent"`
	DeviceInfo       *json.RawMessage `json:"device_info" db:"device_info"`
	ExpiresAt        time.Time        `json:"expires_at" db:"expires_at" validate:"required"`
	RefreshExpiresAt *time.Time       `json:"refresh_expires_at" db:"refresh_expires_at"`
	Status           string           `json:"status" db:"status" validate:"required,max=50"`
	LastActiveAt     time.Time        `json:"last_active_at" db:"last_active_at" validate:"required"`
}

// GeneratedUpdateUserSession contains the data for updating an existing userSession.
// All fields are optional (pointers) to support partial updates.
// Use the type alias in repository.go to reference this type, or embed it to add custom fields.
type GeneratedUpdateUserSession struct {
	UserId           *string          `json:"user_id" db:"user_id"`
	SessionToken     *string          `json:"session_token" db:"session_token"`
	RefreshToken     *string          `json:"refresh_token" db:"refresh_token"`
	IpAddress        *string          `json:"ip_address" db:"ip_address"`
	UserAgent        *string          `json:"user_agent" db:"user_agent"`
	DeviceInfo       *json.RawMessage `json:"device_info" db:"device_info"`
	ExpiresAt        *time.Time       `json:"expires_at" db:"expires_at"`
	RefreshExpiresAt *time.Time       `json:"refresh_expires_at" db:"refresh_expires_at"`
	Status           *string          `json:"status" db:"status"`
	LastActiveAt     *time.Time       `json:"last_active_at" db:"last_active_at"`
	UpdatedAt        *time.Time       `json:"updated_at" db:"updated_at"` // Optional override for updated_at
}

// ========================================
// FILTER, ORDERING, PAGINATION (FOP)
// ========================================

// OrderBy constants for sorting
const (
	OrderByPK               = "session_id"
	OrderByCreatedAt        = "created_at"
	OrderByUpdatedAt        = "updated_at"
	OrderByUserId           = "user_id"
	OrderBySessionToken     = "session_token"
	OrderByRefreshToken     = "refresh_token"
	OrderByIpAddress        = "ip_address"
	OrderByUserAgent        = "user_agent"
	OrderByDeviceInfo       = "device_info"
	OrderByExpiresAt        = "expires_at"
	OrderByRefreshExpiresAt = "refresh_expires_at"
	OrderByStatus           = "status"
	OrderByLastActiveAt     = "last_active_at"
)

// DefaultOrderBy specifies the default sort order
var DefaultOrderBy = fop.NewBy(OrderByCreatedAt, fop.DESC)

// GeneratedUserSessionFilter holds the available fields a query can be filtered on.
// Use the type alias in repository.go to reference this type, or embed it to add custom filters.
type GeneratedUserSessionFilter struct {
	SearchTerm       *string    `json:"search_term,omitempty"`        // Search across text fields
	UserId           *string    `json:"user_id,omitempty"`            // Filter by user_id
	SessionToken     *string    `json:"session_token,omitempty"`      // Filter by session_token
	RefreshToken     *string    `json:"refresh_token,omitempty"`      // Filter by refresh_token
	IpAddress        *string    `json:"ip_address,omitempty"`         // Filter by ip_address
	UserAgent        *string    `json:"user_agent,omitempty"`         // Filter by user_agent
	ExpiresAt        *time.Time `json:"expires_at,omitempty"`         // Filter by expires_at
	RefreshExpiresAt *time.Time `json:"refresh_expires_at,omitempty"` // Filter by refresh_expires_at
	Status           *string    `json:"status,omitempty"`             // Filter by status
	CreatedAtBefore  *time.Time `json:"created_at_before,omitempty"`  // Filter by created_at < value
	CreatedAtAfter   *time.Time `json:"created_at_after,omitempty"`   // Filter by created_at > value
	UpdatedAtBefore  *time.Time `json:"updated_at_before,omitempty"`  // Filter by updated_at < value
	UpdatedAtAfter   *time.Time `json:"updated_at_after,omitempty"`   // Filter by updated_at > value
	LastActiveAt     *time.Time `json:"last_active_at,omitempty"`     // Filter by last_active_at
}

// UserSessionCursor for cursor-based pagination
type UserSessionCursor = fop.Cursor[string, time.Time]

// DecodeUserSessionCursor decodes a cursor token
func DecodeUserSessionCursor(token string) (*UserSessionCursor, error) {
	return fop.DecodeCursor[string, time.Time](token)
}

// EncodeUserSessionCursor encodes a cursor for pagination
func EncodeUserSessionCursor(createdAt time.Time, sessionId string) (string, error) {
	cursor := UserSessionCursor{
		OrderValue: createdAt,
		PK:         sessionId,
	}
	return cursor.Encode()
}

// ========================================
// STORER INTERFACE
// ========================================

// GeneratedStorer defines the auto-generated storage operations for UserSession.
// This interface is regenerated on every schema change.
// To add custom storage methods, embed this interface in your Storer interface in repository.go.
type GeneratedStorer interface {
	// Create inserts a new userSession
	Create(ctx context.Context, input GeneratedCreateUserSession) (GeneratedUserSession, error)

	// Get retrieves a userSession by its ID
	Get(ctx context.Context, sessionId string) (GeneratedUserSession, error)

	// Update modifies an existing userSession
	Update(ctx context.Context, sessionId string, input GeneratedUpdateUserSession) error

	// Delete removes a userSession by its ID
	Delete(ctx context.Context, sessionId string) error

	// List retrieves UserSessions with filters, ordering, and pagination
	List(ctx context.Context, filter GeneratedUserSessionFilter, orderBy fop.By, page fop.PageStringCursor, forPrevious bool) ([]GeneratedUserSession, error)

	// Archive sets the status to 'archived'
	Archive(ctx context.Context, sessionId string) error

	// ListByUserId retrieves UserSessions for a given User
	ListByUserId(ctx context.Context, userId string, orderBy fop.By, page fop.PageStringCursor, forPrevious bool) ([]GeneratedUserSession, error)
}

// ========================================
// GENERATED REPOSITORY
// ========================================

// GeneratedRepository provides default implementations for all UserSession CRUD operations.
// Embed this struct in your custom Repository (in repository.go) to inherit default behavior
// that you can selectively override.
type GeneratedRepository struct {
	log    *logger.Logger
	storer Storer
}

// Create inserts a new userSession
func (r *GeneratedRepository) Create(ctx context.Context, input GeneratedCreateUserSession) (GeneratedUserSession, error) {
	entity, err := r.storer.Create(ctx, input)
	if err != nil {
		return GeneratedUserSession{}, fmt.Errorf("create userSession: %w", err)
	}
	return entity, nil
}

// Get retrieves a userSession by its ID
func (r *GeneratedRepository) Get(ctx context.Context, sessionId string) (GeneratedUserSession, error) {
	entity, err := r.storer.Get(ctx, sessionId)
	if err != nil {
		return GeneratedUserSession{}, fmt.Errorf("get userSession[%v]: %w", sessionId, err)
	}
	return entity, nil
}

// Update modifies an existing userSession
func (r *GeneratedRepository) Update(ctx context.Context, sessionId string, input GeneratedUpdateUserSession) error {
	if err := r.storer.Update(ctx, sessionId, input); err != nil {
		return fmt.Errorf("update userSession[%v]: %w", sessionId, err)
	}
	return nil
}

// Delete removes a userSession by its ID
func (r *GeneratedRepository) Delete(ctx context.Context, sessionId string) error {
	if err := r.storer.Delete(ctx, sessionId); err != nil {
		return fmt.Errorf("delete userSession[%v]: %w", sessionId, err)
	}
	return nil
}

// List retrieves UserSessions with filters, ordering, and pagination
func (r *GeneratedRepository) List(ctx context.Context, filter GeneratedUserSessionFilter, order fop.By, page fop.PageStringCursor) ([]GeneratedUserSession, fop.Pagination, error) {
	// Request one more record than needed to check for next page
	listPage := fop.PageStringCursor{
		Limit:  page.Limit + 1,
		Cursor: page.Cursor,
	}

	// Fetch one more record than requested to determine if there's a next page
	records, err := r.storer.List(ctx, filter, order, listPage, false)
	if err != nil {
		return nil, fop.Pagination{}, fmt.Errorf("query: %w", err)
	}

	returnableRecords := records
	nextCursor := ""

	// If we have more records than the limit, trim the list and set next cursor
	if len(records) > page.Limit {
		returnableRecords = records[:page.Limit]
		lastRecord := returnableRecords[len(returnableRecords)-1]
		nextCursor, err = EncodeUserSessionCursor(lastRecord.CreatedAt, lastRecord.SessionId)
		if err != nil {
			return nil, fop.Pagination{}, fmt.Errorf("encode next cursor: %w", err)
		}
	}

	pagination := fop.Pagination{
		HasPrev:        false,
		Limit:          page.Limit,
		PreviousCursor: "",
		NextCursor:     nextCursor,
		PageTotal:      len(returnableRecords),
	}

	// Check if there's a previous page
	if page.Cursor != "" {
		prevRecords, err := r.storer.List(ctx, filter, order, page, true)
		if err == nil && len(prevRecords) > 0 {
			pagination.HasPrev = true
			if len(prevRecords) == page.Limit {
				// we are re-reversing the order in the storage layer so we should start with the first item instead of the last
				firstRecord := prevRecords[0]
				pagination.PreviousCursor, err = EncodeUserSessionCursor(firstRecord.CreatedAt, firstRecord.SessionId)
				if err != nil {
					return nil, fop.Pagination{}, fmt.Errorf("encode prev cursor: %w", err)
				}
			}
		}
	}

	return returnableRecords, pagination, nil
}

// Archive sets the status to 'archived'
func (r *GeneratedRepository) Archive(ctx context.Context, sessionId string) error {
	if err := r.storer.Archive(ctx, sessionId); err != nil {
		return fmt.Errorf("archive userSession[%v]: %w", sessionId, err)
	}
	return nil
}

// ListByUserId retrieves UserSessions for a given User
func (r *GeneratedRepository) ListByUserId(ctx context.Context, userId string, order fop.By, page fop.PageStringCursor) ([]GeneratedUserSession, fop.Pagination, error) {
	// Request one more record than needed to check for next page
	listPage := fop.PageStringCursor{
		Limit:  page.Limit + 1,
		Cursor: page.Cursor,
	}

	// Fetch records
	records, err := r.storer.ListByUserId(ctx, userId, order, listPage, false)
	if err != nil {
		return nil, fop.Pagination{}, fmt.Errorf("query: %w", err)
	}

	returnableRecords := records
	nextCursor := ""

	// If we have more records than the limit, trim the list and set next cursor
	if len(records) > page.Limit {
		returnableRecords = records[:page.Limit]
		lastRecord := returnableRecords[len(returnableRecords)-1]
		nextCursor, err = EncodeUserSessionCursor(lastRecord.CreatedAt, lastRecord.SessionId)
		if err != nil {
			return nil, fop.Pagination{}, fmt.Errorf("encode next cursor: %w", err)
		}
	}

	pagination := fop.Pagination{
		HasPrev:        false,
		Limit:          page.Limit,
		PreviousCursor: "",
		NextCursor:     nextCursor,
		PageTotal:      len(returnableRecords),
	}

	// Check if there's a previous page
	if page.Cursor != "" {
		prevRecords, err := r.storer.ListByUserId(ctx, userId, order, page, true)
		if err == nil && len(prevRecords) > 0 {
			pagination.HasPrev = true
			if len(prevRecords) == page.Limit {
				firstRecord := prevRecords[0]
				pagination.PreviousCursor, err = EncodeUserSessionCursor(firstRecord.CreatedAt, firstRecord.SessionId)
				if err != nil {
					return nil, fop.Pagination{}, fmt.Errorf("encode prev cursor: %w", err)
				}
			}
		}
	}

	return returnableRecords, pagination, nil
}
