// Code generated by pgxstores. DO NOT EDIT.
// This file contains filter and ordering logic for Task.

package taskspgxstore

import (
	"bytes"
	"strings"

	"github.com/jackc/pgx/v5"
	"github.com/jrazmi/envoker/core/repositories/tasksrepo"
)

// orderByFields maps repository field names to database column names
var orderByFields = map[string]string{
	tasksrepo.OrderByPK:               "task_id",
	tasksrepo.OrderByCreatedAt:        "created_at",
	tasksrepo.OrderByUpdatedAt:        "updated_at",
	tasksrepo.OrderByProcessingStatus: "processing_status",
	tasksrepo.OrderByTaskType:         "task_type",
	tasksrepo.OrderByMetadata:         "metadata",
	tasksrepo.OrderByPriority:         "priority",
	tasksrepo.OrderByMaxRetries:       "max_retries",
	tasksrepo.OrderByRetryCount:       "retry_count",
	tasksrepo.OrderByErrorMessage:     "error_message",
	tasksrepo.OrderByProcessingTimeMs: "processing_time_ms",
	tasksrepo.OrderByLastRunAt:        "last_run_at",
}

// applyFilter applies query filters to the SQL query
func (s *Store) applyFilter(filter tasksrepo.TaskFilter, data pgx.NamedArgs, buf *bytes.Buffer) {
	var conditions []string
	// Filter by processing_status
	if filter.ProcessingStatus != nil {
		conditions = append(conditions, "processing_status = @processingStatus")
		data["processingStatus"] = *filter.ProcessingStatus
	}
	// Filter by created_at - before
	if filter.CreatedAtBefore != nil {
		conditions = append(conditions, "created_at < @createdAt_before")
		data["createdAt_before"] = *filter.CreatedAtBefore
	}

	// Filter by created_at - after
	if filter.CreatedAtAfter != nil {
		conditions = append(conditions, "created_at > @createdAt_after")
		data["createdAt_after"] = *filter.CreatedAtAfter
	}
	// Filter by updated_at - before
	if filter.UpdatedAtBefore != nil {
		conditions = append(conditions, "updated_at < @updatedAt_before")
		data["updatedAt_before"] = *filter.UpdatedAtBefore
	}

	// Filter by updated_at - after
	if filter.UpdatedAtAfter != nil {
		conditions = append(conditions, "updated_at > @updatedAt_after")
		data["updatedAt_after"] = *filter.UpdatedAtAfter
	}
	// Filter by task_type
	if filter.TaskType != nil {
		conditions = append(conditions, "task_type = @taskType")
		data["taskType"] = *filter.TaskType
	}
	// Filter by priority
	if filter.Priority != nil {
		conditions = append(conditions, "priority = @priority")
		data["priority"] = *filter.Priority
	}
	// Filter by max_retries
	if filter.MaxRetries != nil {
		conditions = append(conditions, "max_retries = @maxRetries")
		data["maxRetries"] = *filter.MaxRetries
	}
	// Filter by retry_count
	if filter.RetryCount != nil {
		conditions = append(conditions, "retry_count = @retryCount")
		data["retryCount"] = *filter.RetryCount
	}
	// Filter by error_message
	if filter.ErrorMessage != nil {
		conditions = append(conditions, "error_message = @errorMessage")
		data["errorMessage"] = *filter.ErrorMessage
	}
	// Filter by processing_time_ms
	if filter.ProcessingTimeMs != nil {
		conditions = append(conditions, "processing_time_ms = @processingTimeMs")
		data["processingTimeMs"] = *filter.ProcessingTimeMs
	}
	// Filter by last_run_at
	if filter.LastRunAt != nil {
		conditions = append(conditions, "last_run_at = @lastRunAt")
		data["lastRunAt"] = *filter.LastRunAt
	}

	// Search term across text fields
	if filter.SearchTerm != nil && *filter.SearchTerm != "" {
		searchPattern := "%" + *filter.SearchTerm + "%"
		searchConditions := []string{}
		searchConditions = append(searchConditions, "task_id ILIKE @search_term")
		searchConditions = append(searchConditions, "processing_status ILIKE @search_term")
		searchConditions = append(searchConditions, "task_type ILIKE @search_term")
		searchConditions = append(searchConditions, "error_message ILIKE @search_term")
		if len(searchConditions) > 0 {
			conditions = append(conditions, "("+strings.Join(searchConditions, " OR ")+")")
			data["search_term"] = searchPattern
		}
	}

	// Apply conditions if any exist
	if len(conditions) > 0 {
		buf.WriteString(" WHERE ")
		buf.WriteString(strings.Join(conditions, " AND "))
	}
}
