// Code generated by repositorygen. DO NOT EDIT.
// This file contains the Repository method implementations for Task.

package tasksrepo

import (
	"context"
	"fmt"

	"github.com/jrazmi/envoker/core/scaffolding/fop"
)

// GeneratedStorer defines the auto-generated storage operations for Task
// This interface is regenerated on every schema change. To add custom methods,
// embed this interface in your Storer interface in repo.go (which is not overwritten).
type GeneratedStorer interface {
	// Create inserts a new task
	Create(ctx context.Context, input CreateTask) (Task, error)

	// Get retrieves a task by its ID
	Get(ctx context.Context, taskId string) (Task, error)

	// Update modifies an existing task
	Update(ctx context.Context, taskId string, input UpdateTask) error

	// Delete removes a task by its ID
	Delete(ctx context.Context, taskId string) error

	// List retrieves Tasks with filters, ordering, and pagination
	List(ctx context.Context, filter TaskFilter, orderBy fop.By, page fop.PageStringCursor, forPrevious bool) ([]Task, error)
}

// Create inserts a new task
func (r *Repository) Create(ctx context.Context, input CreateTask) (Task, error) {
	entity, err := r.storer.Create(ctx, input)
	if err != nil {
		return Task{}, fmt.Errorf("create task: %w", err)
	}
	return entity, nil
}

// Get retrieves a task by its ID
func (r *Repository) Get(ctx context.Context, taskId string) (Task, error) {
	entity, err := r.storer.Get(ctx, taskId)
	if err != nil {
		return Task{}, fmt.Errorf("get task[%v]: %w", taskId, err)
	}
	return entity, nil
}

// Update modifies an existing task
func (r *Repository) Update(ctx context.Context, taskId string, input UpdateTask) error {
	if err := r.storer.Update(ctx, taskId, input); err != nil {
		return fmt.Errorf("update task[%v]: %w", taskId, err)
	}
	return nil
}

// Delete removes a task by its ID
func (r *Repository) Delete(ctx context.Context, taskId string) error {
	if err := r.storer.Delete(ctx, taskId); err != nil {
		return fmt.Errorf("delete task[%v]: %w", taskId, err)
	}
	return nil
}

// List retrieves Tasks with filters, ordering, and pagination
func (r *Repository) List(ctx context.Context, filter TaskFilter, order fop.By, page fop.PageStringCursor) ([]Task, fop.Pagination, error) {
	// Request one more record than needed to check for next page
	listPage := fop.PageStringCursor{
		Limit:  page.Limit + 1,
		Cursor: page.Cursor,
	}

	// Fetch one more record than requested to determine if there's a next page
	records, err := r.storer.List(ctx, filter, order, listPage, false)
	if err != nil {
		return nil, fop.Pagination{}, fmt.Errorf("query: %w", err)
	}

	returnableRecords := records
	nextCursor := ""

	// If we have more records than the limit, trim the list and set next cursor
	if len(records) > page.Limit {
		returnableRecords = records[:page.Limit]
		lastRecord := returnableRecords[len(returnableRecords)-1]
		nextCursor, err = EncodeTaskCursor(lastRecord.CreatedAt, lastRecord.TaskId)
		if err != nil {
			return nil, fop.Pagination{}, fmt.Errorf("encode next cursor: %w", err)
		}
	}

	pagination := fop.Pagination{
		HasPrev:        false,
		Limit:          page.Limit,
		PreviousCursor: "",
		NextCursor:     nextCursor,
		PageTotal:      len(returnableRecords),
	}

	// Check if there's a previous page
	if page.Cursor != "" {
		prevRecords, err := r.storer.List(ctx, filter, order, page, true)
		if err == nil && len(prevRecords) > 0 {
			pagination.HasPrev = true
			if len(prevRecords) == page.Limit {
				// we are re-reversing the order in the storage layer so we should start with the first item instead of the last
				firstRecord := prevRecords[0]
				pagination.PreviousCursor, err = EncodeTaskCursor(firstRecord.CreatedAt, firstRecord.TaskId)
				if err != nil {
					return nil, fop.Pagination{}, fmt.Errorf("encode prev cursor: %w", err)
				}
			}
		}
	}

	return returnableRecords, pagination, nil
}
