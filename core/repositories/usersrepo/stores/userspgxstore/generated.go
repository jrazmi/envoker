// Code generated by pgxstores. DO NOT EDIT.
// This file is ALWAYS REGENERATED - do not modify.
// For custom queries, see store.go which embeds the generated store.

package userspgxstore

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/jrazmi/envoker/core/repositories/usersrepo"
	"github.com/jrazmi/envoker/core/scaffolding/fop"
	"github.com/jrazmi/envoker/infrastructure/postgresdb"
	"github.com/jrazmi/envoker/sdk/logger"
)

// ========================================
// GENERATED STORE
// ========================================

// GeneratedStore provides default implementations for all User SQL operations.
// Embed this struct in your custom Store (in store.go) to inherit default behavior
// that you can selectively override.
type GeneratedStore struct {
	log  *logger.Logger
	pool *postgresdb.Pool
}

// Create inserts a new User
func (s *GeneratedStore) Create(ctx context.Context, input usersrepo.CreateUser) (usersrepo.User, error) {
	// PK not in Create struct - let database generate it
	query := `INSERT INTO public.users (email, username, password_hash, password_salt, first_name, last_name, display_name, email_verified, email_verified_at, role, permissions, last_login_at, last_login_ip, failed_login_attempts, locked_until, password_reset_token, password_reset_expires_at, metadata, status) VALUES (@email, @username, @password_hash, @password_salt, @first_name, @last_name, @display_name, @email_verified, @email_verified_at, @role, @permissions, @last_login_at, @last_login_ip, @failed_login_attempts, @locked_until, @password_reset_token, @password_reset_expires_at, @metadata, @status) RETURNING user_id, email, username, password_hash, password_salt, first_name, last_name, display_name, email_verified, email_verified_at, role, permissions, last_login_at, last_login_ip, failed_login_attempts, locked_until, password_reset_token, password_reset_expires_at, metadata, status, created_at, updated_at`

	args := pgx.NamedArgs{
		"email":                     input.Email,
		"username":                  input.Username,
		"password_hash":             input.PasswordHash,
		"password_salt":             input.PasswordSalt,
		"first_name":                input.FirstName,
		"last_name":                 input.LastName,
		"display_name":              input.DisplayName,
		"email_verified":            input.EmailVerified,
		"email_verified_at":         input.EmailVerifiedAt,
		"role":                      input.Role,
		"permissions":               input.Permissions,
		"last_login_at":             input.LastLoginAt,
		"last_login_ip":             input.LastLoginIp,
		"failed_login_attempts":     input.FailedLoginAttempts,
		"locked_until":              input.LockedUntil,
		"password_reset_token":      input.PasswordResetToken,
		"password_reset_expires_at": input.PasswordResetExpiresAt,
		"metadata":                  input.Metadata,
		"status":                    input.Status,
	}

	rows, err := s.pool.Query(ctx, query, args)
	if err != nil {
		return usersrepo.User{}, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	record, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[usersrepo.User])
	if err != nil {
		return usersrepo.User{}, postgresdb.HandlePgError(err)
	}

	return record, nil
}

// Get retrieves a single User by ID
func (s *GeneratedStore) Get(ctx context.Context, userId string) (usersrepo.User, error) {
	query := `SELECT user_id, email, username, password_hash, password_salt, first_name, last_name, display_name, email_verified, email_verified_at, role, permissions, last_login_at, last_login_ip, failed_login_attempts, locked_until, password_reset_token, password_reset_expires_at, metadata, status, created_at, updated_at FROM public.users WHERE user_id = @userId`

	args := pgx.NamedArgs{
		"userId": userId,
	}

	rows, err := s.pool.Query(ctx, query, args)
	if err != nil {
		return usersrepo.User{}, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	record, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[usersrepo.User])
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return usersrepo.User{}, fmt.Errorf("User not found")
		}
		return usersrepo.User{}, postgresdb.HandlePgError(err)
	}

	return record, nil
}

// Update modifies an existing User
func (s *GeneratedStore) Update(ctx context.Context, userId string, input usersrepo.UpdateUser) error {
	buf := bytes.NewBufferString("UPDATE public.users SET ")
	args := pgx.NamedArgs{
		"userId": userId,
	}
	var fields []string
	if input.Email != nil {
		fields = append(fields, "email = @email")
		args["email"] = *input.Email
	}
	if input.Username != nil {
		fields = append(fields, "username = @username")
		args["username"] = *input.Username
	}
	if input.PasswordHash != nil {
		fields = append(fields, "password_hash = @password_hash")
		args["password_hash"] = *input.PasswordHash
	}
	if input.PasswordSalt != nil {
		fields = append(fields, "password_salt = @password_salt")
		args["password_salt"] = *input.PasswordSalt
	}
	if input.FirstName != nil {
		fields = append(fields, "first_name = @first_name")
		args["first_name"] = *input.FirstName
	}
	if input.LastName != nil {
		fields = append(fields, "last_name = @last_name")
		args["last_name"] = *input.LastName
	}
	if input.DisplayName != nil {
		fields = append(fields, "display_name = @display_name")
		args["display_name"] = *input.DisplayName
	}
	if input.EmailVerified != nil {
		fields = append(fields, "email_verified = @email_verified")
		args["email_verified"] = *input.EmailVerified
	}
	if input.EmailVerifiedAt != nil {
		fields = append(fields, "email_verified_at = @email_verified_at")
		args["email_verified_at"] = *input.EmailVerifiedAt
	}
	if input.Role != nil {
		fields = append(fields, "role = @role")
		args["role"] = *input.Role
	}
	if input.Permissions != nil {
		fields = append(fields, "permissions = @permissions")
		args["permissions"] = *input.Permissions
	}
	if input.LastLoginAt != nil {
		fields = append(fields, "last_login_at = @last_login_at")
		args["last_login_at"] = *input.LastLoginAt
	}
	if input.LastLoginIp != nil {
		fields = append(fields, "last_login_ip = @last_login_ip")
		args["last_login_ip"] = *input.LastLoginIp
	}
	if input.FailedLoginAttempts != nil {
		fields = append(fields, "failed_login_attempts = @failed_login_attempts")
		args["failed_login_attempts"] = *input.FailedLoginAttempts
	}
	if input.LockedUntil != nil {
		fields = append(fields, "locked_until = @locked_until")
		args["locked_until"] = *input.LockedUntil
	}
	if input.PasswordResetToken != nil {
		fields = append(fields, "password_reset_token = @password_reset_token")
		args["password_reset_token"] = *input.PasswordResetToken
	}
	if input.PasswordResetExpiresAt != nil {
		fields = append(fields, "password_reset_expires_at = @password_reset_expires_at")
		args["password_reset_expires_at"] = *input.PasswordResetExpiresAt
	}
	if input.Metadata != nil {
		fields = append(fields, "metadata = @metadata")
		args["metadata"] = *input.Metadata
	}
	if input.Status != nil {
		fields = append(fields, "status = @status")
		args["status"] = *input.Status
	}

	// Always update the updated_at field
	now := time.Now().UTC()
	if input.UpdatedAt != nil {
		args["updated_at"] = *input.UpdatedAt
	} else {
		args["updated_at"] = now
	}
	fields = append(fields, "updated_at = @updated_at")

	// If no fields to update besides updated_at, return early
	if len(fields) == 1 {
		return fmt.Errorf("no fields to update")
	}

	// Join fields and complete the query
	buf.WriteString(strings.Join(fields, ", "))
	buf.WriteString(" WHERE user_id = @userId")

	query := buf.String()
	s.log.DebugContext(ctx, "update User", "query", query, "userId", userId)

	result, err := s.pool.Exec(ctx, query, args)
	if err != nil {
		return postgresdb.HandlePgError(err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("User not found")
	}

	return nil
}

// Delete removes a User by ID
func (s *GeneratedStore) Delete(ctx context.Context, userId string) error {
	query := `DELETE FROM public.users WHERE user_id = @userId`

	args := pgx.NamedArgs{
		"userId": userId,
	}

	result, err := s.pool.Exec(ctx, query, args)
	if err != nil {
		return postgresdb.HandlePgError(err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("User not found")
	}

	return nil
}

// List retrieves User records with filtering, ordering, and cursor pagination
func (s *GeneratedStore) List(ctx context.Context, filter usersrepo.UserFilter, orderBy fop.By, page fop.PageStringCursor, forPrevious bool) ([]usersrepo.User, error) {
	data := pgx.NamedArgs{}

	// Start building the query
	buf := bytes.NewBufferString(`
		SELECT
			user_id,
			email,
			username,
			password_hash,
			password_salt,
			first_name,
			last_name,
			display_name,
			email_verified,
			email_verified_at,
			role,
			permissions,
			last_login_at,
			last_login_ip,
			failed_login_attempts,
			locked_until,
			password_reset_token,
			password_reset_expires_at,
			metadata,
			status,
			created_at,
			updated_at
		FROM
			public.users`)

	// Apply filters
	s.applyFilter(filter, data, buf)

	// Setup configuration for string cursor pagination
	cursorConfig := postgresdb.StringCursorConfig{
		Cursor:     page.Cursor,
		OrderField: orderByFields[orderBy.Field],
		PKField:    "user_id",
		TableName:  "users",
		Direction:  orderBy.Direction,
		Limit:      page.Limit,
	}

	// Apply cursor pagination
	if page.Cursor != "" {
		err := postgresdb.ApplyStringCursorPagination[time.Time](buf, data, cursorConfig, forPrevious)
		if err != nil {
			return nil, fmt.Errorf("cursorpagination: %s", err)
		}
	}

	// Add ordering
	err := postgresdb.AddOrderByClause(buf, cursorConfig.OrderField, cursorConfig.PKField, cursorConfig.Direction, forPrevious)
	if err != nil {
		return nil, fmt.Errorf("order: %w", err)
	}

	// Add limit
	postgresdb.AddLimitClause(cursorConfig.Limit, data, buf)

	// Execute the query
	query := buf.String()
	s.log.DebugContext(ctx, "list User", "query", query)

	rows, err := s.pool.Query(ctx, query, data)
	if err != nil {
		return nil, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	entities, err := pgx.CollectRows(rows, pgx.RowToStructByName[usersrepo.User])
	if err != nil {
		return nil, postgresdb.HandlePgError(err)
	}

	// If we were getting previous page, reverse the results back to correct order
	if forPrevious && len(entities) > 0 {
		for i, j := 0, len(entities)-1; i < j; i, j = i+1, j-1 {
			entities[i], entities[j] = entities[j], entities[i]
		}
	}

	return entities, nil
}

// Archive sets the status to 'archived'
func (s *GeneratedStore) Archive(ctx context.Context, userId string) error {
	data := pgx.NamedArgs{
		"userId": userId,
		"status": "archived",
	}

	query := `UPDATE public.users SET status = @status`

	query += ` WHERE user_id = @userId`

	result, err := s.pool.Exec(ctx, query, data)
	if err != nil {
		return postgresdb.HandlePgError(err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("User not found")
	}

	return nil
}

// ========================================
// FILTER & ORDERING HELPERS
// ========================================

// orderByFields maps repository field names to database column names
var orderByFields = map[string]string{
	usersrepo.OrderByPK:                     "user_id",
	usersrepo.OrderByCreatedAt:              "created_at",
	usersrepo.OrderByUpdatedAt:              "updated_at",
	usersrepo.OrderByEmail:                  "email",
	usersrepo.OrderByUsername:               "username",
	usersrepo.OrderByPasswordHash:           "password_hash",
	usersrepo.OrderByPasswordSalt:           "password_salt",
	usersrepo.OrderByFirstName:              "first_name",
	usersrepo.OrderByLastName:               "last_name",
	usersrepo.OrderByDisplayName:            "display_name",
	usersrepo.OrderByEmailVerified:          "email_verified",
	usersrepo.OrderByEmailVerifiedAt:        "email_verified_at",
	usersrepo.OrderByRole:                   "role",
	usersrepo.OrderByPermissions:            "permissions",
	usersrepo.OrderByLastLoginAt:            "last_login_at",
	usersrepo.OrderByLastLoginIp:            "last_login_ip",
	usersrepo.OrderByFailedLoginAttempts:    "failed_login_attempts",
	usersrepo.OrderByLockedUntil:            "locked_until",
	usersrepo.OrderByPasswordResetToken:     "password_reset_token",
	usersrepo.OrderByPasswordResetExpiresAt: "password_reset_expires_at",
	usersrepo.OrderByMetadata:               "metadata",
	usersrepo.OrderByStatus:                 "status",
}

// applyFilter applies query filters to the SQL query
func (s *GeneratedStore) applyFilter(filter usersrepo.UserFilter, data pgx.NamedArgs, buf *bytes.Buffer) {
	var conditions []string
	// Filter by email
	if filter.Email != nil {
		conditions = append(conditions, "email = @email")
		data["email"] = *filter.Email
	}
	// Filter by username
	if filter.Username != nil {
		conditions = append(conditions, "username = @username")
		data["username"] = *filter.Username
	}
	// Filter by password_hash
	if filter.PasswordHash != nil {
		conditions = append(conditions, "password_hash = @passwordHash")
		data["passwordHash"] = *filter.PasswordHash
	}
	// Filter by password_salt
	if filter.PasswordSalt != nil {
		conditions = append(conditions, "password_salt = @passwordSalt")
		data["passwordSalt"] = *filter.PasswordSalt
	}
	// Filter by first_name
	if filter.FirstName != nil {
		conditions = append(conditions, "first_name = @firstName")
		data["firstName"] = *filter.FirstName
	}
	// Filter by last_name
	if filter.LastName != nil {
		conditions = append(conditions, "last_name = @lastName")
		data["lastName"] = *filter.LastName
	}
	// Filter by display_name
	if filter.DisplayName != nil {
		conditions = append(conditions, "display_name = @displayName")
		data["displayName"] = *filter.DisplayName
	}
	// Filter by email_verified
	if filter.EmailVerified != nil {
		conditions = append(conditions, "email_verified = @emailVerified")
		data["emailVerified"] = *filter.EmailVerified
	}
	// Filter by email_verified_at
	if filter.EmailVerifiedAt != nil {
		conditions = append(conditions, "email_verified_at = @emailVerifiedAt")
		data["emailVerifiedAt"] = *filter.EmailVerifiedAt
	}
	// Filter by role
	if filter.Role != nil {
		conditions = append(conditions, "role = @role")
		data["role"] = *filter.Role
	}
	// Filter by last_login_at
	if filter.LastLoginAt != nil {
		conditions = append(conditions, "last_login_at = @lastLoginAt")
		data["lastLoginAt"] = *filter.LastLoginAt
	}
	// Filter by last_login_ip
	if filter.LastLoginIp != nil {
		conditions = append(conditions, "last_login_ip = @lastLoginIp")
		data["lastLoginIp"] = *filter.LastLoginIp
	}
	// Filter by failed_login_attempts
	if filter.FailedLoginAttempts != nil {
		conditions = append(conditions, "failed_login_attempts = @failedLoginAttempts")
		data["failedLoginAttempts"] = *filter.FailedLoginAttempts
	}
	// Filter by locked_until
	if filter.LockedUntil != nil {
		conditions = append(conditions, "locked_until = @lockedUntil")
		data["lockedUntil"] = *filter.LockedUntil
	}
	// Filter by password_reset_token
	if filter.PasswordResetToken != nil {
		conditions = append(conditions, "password_reset_token = @passwordResetToken")
		data["passwordResetToken"] = *filter.PasswordResetToken
	}
	// Filter by password_reset_expires_at
	if filter.PasswordResetExpiresAt != nil {
		conditions = append(conditions, "password_reset_expires_at = @passwordResetExpiresAt")
		data["passwordResetExpiresAt"] = *filter.PasswordResetExpiresAt
	}
	// Filter by status
	if filter.Status != nil {
		conditions = append(conditions, "status = @status")
		data["status"] = *filter.Status
	}
	// Filter by created_at - before
	if filter.CreatedAtBefore != nil {
		conditions = append(conditions, "created_at < @createdAt_before")
		data["createdAt_before"] = *filter.CreatedAtBefore
	}

	// Filter by created_at - after
	if filter.CreatedAtAfter != nil {
		conditions = append(conditions, "created_at > @createdAt_after")
		data["createdAt_after"] = *filter.CreatedAtAfter
	}
	// Filter by updated_at - before
	if filter.UpdatedAtBefore != nil {
		conditions = append(conditions, "updated_at < @updatedAt_before")
		data["updatedAt_before"] = *filter.UpdatedAtBefore
	}

	// Filter by updated_at - after
	if filter.UpdatedAtAfter != nil {
		conditions = append(conditions, "updated_at > @updatedAt_after")
		data["updatedAt_after"] = *filter.UpdatedAtAfter
	}

	// Search term across text fields
	if filter.SearchTerm != nil && *filter.SearchTerm != "" {
		searchPattern := "%" + *filter.SearchTerm + "%"
		searchConditions := []string{}
		searchConditions = append(searchConditions, "email ILIKE @search_term")
		searchConditions = append(searchConditions, "username ILIKE @search_term")
		searchConditions = append(searchConditions, "password_hash ILIKE @search_term")
		searchConditions = append(searchConditions, "password_salt ILIKE @search_term")
		searchConditions = append(searchConditions, "first_name ILIKE @search_term")
		searchConditions = append(searchConditions, "last_name ILIKE @search_term")
		searchConditions = append(searchConditions, "display_name ILIKE @search_term")
		searchConditions = append(searchConditions, "role ILIKE @search_term")
		searchConditions = append(searchConditions, "password_reset_token ILIKE @search_term")
		searchConditions = append(searchConditions, "status ILIKE @search_term")
		if len(searchConditions) > 0 {
			conditions = append(conditions, "("+strings.Join(searchConditions, " OR ")+")")
			data["search_term"] = searchPattern
		}
	}

	// Apply conditions if any exist
	if len(conditions) > 0 {
		buf.WriteString(" WHERE ")
		buf.WriteString(strings.Join(conditions, " AND "))
	}
}
