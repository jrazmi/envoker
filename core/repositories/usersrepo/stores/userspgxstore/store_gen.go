// Code generated by storegen. DO NOT EDIT.

package userspgxstore

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/jrazmi/envoker/core/repositories/usersrepo"
	"github.com/jrazmi/envoker/core/scaffolding/fop"
	"github.com/jrazmi/envoker/infrastructure/databases/postgresdb"
	"github.com/jrazmi/envoker/sdk/cryptids"
)

// Get retrieves a single User by ID
func (s *Store) Get(ctx context.Context, ID string, filter usersrepo.UserFilter) (usersrepo.User, error) {
	query := `SELECT user_id, email FROM public.users WHERE user_id = @user_id`
	
	args := pgx.NamedArgs{
		"user_id": ID,
	}
	
	rows, err := s.pool.Query(ctx, query, args)
	if err != nil {
		return usersrepo.User{}, postgresdb.HandlePgError(err)
	}
	defer rows.Close()
	
	record, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[usersrepo.User])
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return usersrepo.User{}, usersrepo.ErrUserNotFound
		}
		return usersrepo.User{}, postgresdb.HandlePgError(err)
	}
	
	return record, nil
}

// Create inserts a new User
func (s *Store) Create(ctx context.Context, input *usersrepo.CreateUser) (usersrepo.User, error) {
	// Generate ID using cryptids
	id, err := cryptids.GenerateID()
	if err != nil {
		return usersrepo.User{}, fmt.Errorf("generate id: %w", err)
	}

	query := `INSERT INTO public.users (user_id, email) VALUES (@user_id, @email) RETURNING *`

	args := pgx.NamedArgs{
		"user_id": id,
		"email": input.Email,
	}

	rows, err := s.pool.Query(ctx, query, args)
	if err != nil {
		return usersrepo.User{}, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	record, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[usersrepo.User])
	if err != nil {
		return usersrepo.User{}, postgresdb.HandlePgError(err)
	}

	return record, nil
}

// Update modifies an existing User
func (s *Store) Update(ctx context.Context, ID string, input *usersrepo.UpdateUser) error {
	var fields []string
	data := pgx.NamedArgs{
		"user_id": ID,
	}
	

	if input.Email != nil {
		fields = append(fields, "email = @email")
		data["email"] = input.Email
	}
	

	
	if len(fields) == 0 {
		return fmt.Errorf("no fields to update")
	}
	
	query := fmt.Sprintf(`UPDATE public.users SET %s WHERE user_id = @user_id`, strings.Join(fields, ", "))
	
	result, err := s.pool.Exec(ctx, query, data)
	if err != nil {
		return postgresdb.HandlePgError(err)
	}
	
	if result.RowsAffected() == 0 {
		return fmt.Errorf("User not found: %s", ID)
	}
	
	return nil
}

// Delete removes a User
func (s *Store) Delete(ctx context.Context, ID string) error {
	query := `DELETE FROM public.users WHERE user_id = @user_id`

	args := pgx.NamedArgs{
		"user_id": ID,
	}

	result, err := s.pool.Exec(ctx, query, args)
	if err != nil {
		return postgresdb.HandlePgError(err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("User not found: %s", ID)
	}

	return nil
}

// List retrieves multiple User records with filtering, ordering, and pagination
func (s *Store) List(ctx context.Context, filter usersrepo.UserFilter, orderBy fop.By, page fop.PageStringCursor) ([]usersrepo.User, error) {
	// TODO: Implement filtering, ordering, and pagination logic
	query := `SELECT user_id, email FROM public.users LIMIT 100`

	rows, err := s.pool.Query(ctx, query)
	if err != nil {
		return nil, postgresdb.HandlePgError(err)
	}
	defer rows.Close()

	records, err := pgx.CollectRows(rows, pgx.RowToStructByName[usersrepo.User])
	if err != nil {
		return nil, postgresdb.HandlePgError(err)
	}

	return records, nil
}

// Archive soft-deletes a User by setting archived_at
func (s *Store) Archive(ctx context.Context, ID string) error {
	query := `UPDATE public.users SET archived_at = @archived_at WHERE user_id = @user_id`

	args := pgx.NamedArgs{
		"user_id":        ID,
		"archived_at": time.Now(),
	}

	result, err := s.pool.Exec(ctx, query, args)
	if err != nil {
		return postgresdb.HandlePgError(err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("User not found: %s", ID)
	}

	return nil
}
