// Code generated by repositorygen. DO NOT EDIT.
// This file is ALWAYS REGENERATED - do not modify.
// For customizations, see repository.go which embeds the generated types.

package usersrepo

import (
	"context"
	"fmt"

	"encoding/json"
	"time"

	"github.com/jrazmi/envoker/core/scaffolding/fop"
	"github.com/jrazmi/envoker/sdk/logger"
)

// ========================================
// MODELS
// ========================================

// GeneratedUser represents a user entity from the database.
// Use the type alias in repository.go to reference this type, or embed it to extend.
type GeneratedUser struct {
	UserId                 string           `json:"user_id" db:"user_id" validate:"required,uuid"`
	Email                  string           `json:"email" db:"email" validate:"required,max=255,email"`
	Username               *string          `json:"username" db:"username" validate:"max=100"`
	PasswordHash           *string          `json:"password_hash" db:"password_hash" validate:"max=255"`
	PasswordSalt           *string          `json:"password_salt" db:"password_salt" validate:"max=255"`
	FirstName              *string          `json:"first_name" db:"first_name" validate:"max=100"`
	LastName               *string          `json:"last_name" db:"last_name" validate:"max=100"`
	DisplayName            *string          `json:"display_name" db:"display_name" validate:"max=255"`
	EmailVerified          *bool            `json:"email_verified" db:"email_verified" validate:"email"`
	EmailVerifiedAt        *time.Time       `json:"email_verified_at" db:"email_verified_at" validate:"email"`
	Role                   *string          `json:"role" db:"role" validate:"max=50"`
	Permissions            *json.RawMessage `json:"permissions" db:"permissions"`
	LastLoginAt            *time.Time       `json:"last_login_at" db:"last_login_at"`
	LastLoginIp            *string          `json:"last_login_ip" db:"last_login_ip"`
	FailedLoginAttempts    *int             `json:"failed_login_attempts" db:"failed_login_attempts"`
	LockedUntil            *time.Time       `json:"locked_until" db:"locked_until"`
	PasswordResetToken     *string          `json:"password_reset_token" db:"password_reset_token" validate:"max=255"`
	PasswordResetExpiresAt *time.Time       `json:"password_reset_expires_at" db:"password_reset_expires_at"`
	Metadata               *json.RawMessage `json:"metadata" db:"metadata"`
	Status                 string           `json:"status" db:"status" validate:"required,max=50"`
	CreatedAt              time.Time        `json:"created_at" db:"created_at" validate:"required"`
	UpdatedAt              time.Time        `json:"updated_at" db:"updated_at" validate:"required"`
}

// GeneratedCreateUser contains the data needed to create a new user.
// Use the type alias in repository.go to reference this type, or embed it to add custom fields.
type GeneratedCreateUser struct {
	Email                  string           `json:"email" db:"email" validate:"required,max=255,email"`
	Username               *string          `json:"username" db:"username" validate:"max=100"`
	PasswordHash           *string          `json:"password_hash" db:"password_hash" validate:"max=255"`
	PasswordSalt           *string          `json:"password_salt" db:"password_salt" validate:"max=255"`
	FirstName              *string          `json:"first_name" db:"first_name" validate:"max=100"`
	LastName               *string          `json:"last_name" db:"last_name" validate:"max=100"`
	DisplayName            *string          `json:"display_name" db:"display_name" validate:"max=255"`
	EmailVerified          *bool            `json:"email_verified" db:"email_verified" validate:"email"`
	EmailVerifiedAt        *time.Time       `json:"email_verified_at" db:"email_verified_at" validate:"email"`
	Role                   *string          `json:"role" db:"role" validate:"max=50"`
	Permissions            *json.RawMessage `json:"permissions" db:"permissions"`
	LastLoginAt            *time.Time       `json:"last_login_at" db:"last_login_at"`
	LastLoginIp            *string          `json:"last_login_ip" db:"last_login_ip"`
	FailedLoginAttempts    *int             `json:"failed_login_attempts" db:"failed_login_attempts"`
	LockedUntil            *time.Time       `json:"locked_until" db:"locked_until"`
	PasswordResetToken     *string          `json:"password_reset_token" db:"password_reset_token" validate:"max=255"`
	PasswordResetExpiresAt *time.Time       `json:"password_reset_expires_at" db:"password_reset_expires_at"`
	Metadata               *json.RawMessage `json:"metadata" db:"metadata"`
	Status                 string           `json:"status" db:"status" validate:"required,max=50"`
}

// GeneratedUpdateUser contains the data for updating an existing user.
// All fields are optional (pointers) to support partial updates.
// Use the type alias in repository.go to reference this type, or embed it to add custom fields.
type GeneratedUpdateUser struct {
	Email                  *string          `json:"email" db:"email"`
	Username               *string          `json:"username" db:"username"`
	PasswordHash           *string          `json:"password_hash" db:"password_hash"`
	PasswordSalt           *string          `json:"password_salt" db:"password_salt"`
	FirstName              *string          `json:"first_name" db:"first_name"`
	LastName               *string          `json:"last_name" db:"last_name"`
	DisplayName            *string          `json:"display_name" db:"display_name"`
	EmailVerified          *bool            `json:"email_verified" db:"email_verified"`
	EmailVerifiedAt        *time.Time       `json:"email_verified_at" db:"email_verified_at"`
	Role                   *string          `json:"role" db:"role"`
	Permissions            *json.RawMessage `json:"permissions" db:"permissions"`
	LastLoginAt            *time.Time       `json:"last_login_at" db:"last_login_at"`
	LastLoginIp            *string          `json:"last_login_ip" db:"last_login_ip"`
	FailedLoginAttempts    *int             `json:"failed_login_attempts" db:"failed_login_attempts"`
	LockedUntil            *time.Time       `json:"locked_until" db:"locked_until"`
	PasswordResetToken     *string          `json:"password_reset_token" db:"password_reset_token"`
	PasswordResetExpiresAt *time.Time       `json:"password_reset_expires_at" db:"password_reset_expires_at"`
	Metadata               *json.RawMessage `json:"metadata" db:"metadata"`
	Status                 *string          `json:"status" db:"status"`
	UpdatedAt              *time.Time       `json:"updated_at" db:"updated_at"` // Optional override for updated_at
}

// ========================================
// FILTER, ORDERING, PAGINATION (FOP)
// ========================================

// OrderBy constants for sorting
const (
	OrderByPK                     = "user_id"
	OrderByCreatedAt              = "created_at"
	OrderByUpdatedAt              = "updated_at"
	OrderByEmail                  = "email"
	OrderByUsername               = "username"
	OrderByPasswordHash           = "password_hash"
	OrderByPasswordSalt           = "password_salt"
	OrderByFirstName              = "first_name"
	OrderByLastName               = "last_name"
	OrderByDisplayName            = "display_name"
	OrderByEmailVerified          = "email_verified"
	OrderByEmailVerifiedAt        = "email_verified_at"
	OrderByRole                   = "role"
	OrderByPermissions            = "permissions"
	OrderByLastLoginAt            = "last_login_at"
	OrderByLastLoginIp            = "last_login_ip"
	OrderByFailedLoginAttempts    = "failed_login_attempts"
	OrderByLockedUntil            = "locked_until"
	OrderByPasswordResetToken     = "password_reset_token"
	OrderByPasswordResetExpiresAt = "password_reset_expires_at"
	OrderByMetadata               = "metadata"
	OrderByStatus                 = "status"
)

// DefaultOrderBy specifies the default sort order
var DefaultOrderBy = fop.NewBy(OrderByCreatedAt, fop.DESC)

// GeneratedUserFilter holds the available fields a query can be filtered on.
// Use the type alias in repository.go to reference this type, or embed it to add custom filters.
type GeneratedUserFilter struct {
	SearchTerm             *string    `json:"search_term,omitempty"`               // Search across text fields
	Email                  *string    `json:"email,omitempty"`                     // Filter by email
	Username               *string    `json:"username,omitempty"`                  // Filter by username
	PasswordHash           *string    `json:"password_hash,omitempty"`             // Filter by password_hash
	PasswordSalt           *string    `json:"password_salt,omitempty"`             // Filter by password_salt
	FirstName              *string    `json:"first_name,omitempty"`                // Filter by first_name
	LastName               *string    `json:"last_name,omitempty"`                 // Filter by last_name
	DisplayName            *string    `json:"display_name,omitempty"`              // Filter by display_name
	EmailVerified          *bool      `json:"email_verified,omitempty"`            // Filter by email_verified
	EmailVerifiedAt        *time.Time `json:"email_verified_at,omitempty"`         // Filter by email_verified_at
	Role                   *string    `json:"role,omitempty"`                      // Filter by role
	LastLoginAt            *time.Time `json:"last_login_at,omitempty"`             // Filter by last_login_at
	LastLoginIp            *string    `json:"last_login_ip,omitempty"`             // Filter by last_login_ip
	FailedLoginAttempts    *int       `json:"failed_login_attempts,omitempty"`     // Filter by failed_login_attempts
	LockedUntil            *time.Time `json:"locked_until,omitempty"`              // Filter by locked_until
	PasswordResetToken     *string    `json:"password_reset_token,omitempty"`      // Filter by password_reset_token
	PasswordResetExpiresAt *time.Time `json:"password_reset_expires_at,omitempty"` // Filter by password_reset_expires_at
	Status                 *string    `json:"status,omitempty"`                    // Filter by status
	CreatedAtBefore        *time.Time `json:"created_at_before,omitempty"`         // Filter by created_at < value
	CreatedAtAfter         *time.Time `json:"created_at_after,omitempty"`          // Filter by created_at > value
	UpdatedAtBefore        *time.Time `json:"updated_at_before,omitempty"`         // Filter by updated_at < value
	UpdatedAtAfter         *time.Time `json:"updated_at_after,omitempty"`          // Filter by updated_at > value
}

// UserCursor for cursor-based pagination
type UserCursor = fop.Cursor[string, time.Time]

// DecodeUserCursor decodes a cursor token
func DecodeUserCursor(token string) (*UserCursor, error) {
	return fop.DecodeCursor[string, time.Time](token)
}

// EncodeUserCursor encodes a cursor for pagination
func EncodeUserCursor(createdAt time.Time, userId string) (string, error) {
	cursor := UserCursor{
		OrderValue: createdAt,
		PK:         userId,
	}
	return cursor.Encode()
}

// ========================================
// STORER INTERFACE
// ========================================

// GeneratedStorer defines the auto-generated storage operations for User.
// This interface is regenerated on every schema change.
// To add custom storage methods, embed this interface in your Storer interface in repository.go.
type GeneratedStorer interface {
	// Create inserts a new user
	Create(ctx context.Context, input GeneratedCreateUser) (GeneratedUser, error)

	// Get retrieves a user by its ID
	Get(ctx context.Context, userId string) (GeneratedUser, error)

	// Update modifies an existing user
	Update(ctx context.Context, userId string, input GeneratedUpdateUser) error

	// Delete removes a user by its ID
	Delete(ctx context.Context, userId string) error

	// List retrieves Users with filters, ordering, and pagination
	List(ctx context.Context, filter GeneratedUserFilter, orderBy fop.By, page fop.PageStringCursor, forPrevious bool) ([]GeneratedUser, error)

	// Archive sets the status to 'archived'
	Archive(ctx context.Context, userId string) error
}

// ========================================
// GENERATED REPOSITORY
// ========================================

// GeneratedRepository provides default implementations for all User CRUD operations.
// Embed this struct in your custom Repository (in repository.go) to inherit default behavior
// that you can selectively override.
type GeneratedRepository struct {
	log    *logger.Logger
	storer Storer
}

// Create inserts a new user
func (r *GeneratedRepository) Create(ctx context.Context, input GeneratedCreateUser) (GeneratedUser, error) {
	entity, err := r.storer.Create(ctx, input)
	if err != nil {
		return GeneratedUser{}, fmt.Errorf("create user: %w", err)
	}
	return entity, nil
}

// Get retrieves a user by its ID
func (r *GeneratedRepository) Get(ctx context.Context, userId string) (GeneratedUser, error) {
	entity, err := r.storer.Get(ctx, userId)
	if err != nil {
		return GeneratedUser{}, fmt.Errorf("get user[%v]: %w", userId, err)
	}
	return entity, nil
}

// Update modifies an existing user
func (r *GeneratedRepository) Update(ctx context.Context, userId string, input GeneratedUpdateUser) error {
	if err := r.storer.Update(ctx, userId, input); err != nil {
		return fmt.Errorf("update user[%v]: %w", userId, err)
	}
	return nil
}

// Delete removes a user by its ID
func (r *GeneratedRepository) Delete(ctx context.Context, userId string) error {
	if err := r.storer.Delete(ctx, userId); err != nil {
		return fmt.Errorf("delete user[%v]: %w", userId, err)
	}
	return nil
}

// List retrieves Users with filters, ordering, and pagination
func (r *GeneratedRepository) List(ctx context.Context, filter GeneratedUserFilter, order fop.By, page fop.PageStringCursor) ([]GeneratedUser, fop.Pagination, error) {
	// Request one more record than needed to check for next page
	listPage := fop.PageStringCursor{
		Limit:  page.Limit + 1,
		Cursor: page.Cursor,
	}

	// Fetch one more record than requested to determine if there's a next page
	records, err := r.storer.List(ctx, filter, order, listPage, false)
	if err != nil {
		return nil, fop.Pagination{}, fmt.Errorf("query: %w", err)
	}

	returnableRecords := records
	nextCursor := ""

	// If we have more records than the limit, trim the list and set next cursor
	if len(records) > page.Limit {
		returnableRecords = records[:page.Limit]
		lastRecord := returnableRecords[len(returnableRecords)-1]
		nextCursor, err = EncodeUserCursor(lastRecord.CreatedAt, lastRecord.UserId)
		if err != nil {
			return nil, fop.Pagination{}, fmt.Errorf("encode next cursor: %w", err)
		}
	}

	pagination := fop.Pagination{
		HasPrev:        false,
		Limit:          page.Limit,
		PreviousCursor: "",
		NextCursor:     nextCursor,
		PageTotal:      len(returnableRecords),
	}

	// Check if there's a previous page
	if page.Cursor != "" {
		prevRecords, err := r.storer.List(ctx, filter, order, page, true)
		if err == nil && len(prevRecords) > 0 {
			pagination.HasPrev = true
			if len(prevRecords) == page.Limit {
				// we are re-reversing the order in the storage layer so we should start with the first item instead of the last
				firstRecord := prevRecords[0]
				pagination.PreviousCursor, err = EncodeUserCursor(firstRecord.CreatedAt, firstRecord.UserId)
				if err != nil {
					return nil, fop.Pagination{}, fmt.Errorf("encode prev cursor: %w", err)
				}
			}
		}
	}

	return returnableRecords, pagination, nil
}

// Archive sets the status to 'archived'
func (r *GeneratedRepository) Archive(ctx context.Context, userId string) error {
	if err := r.storer.Archive(ctx, userId); err != nil {
		return fmt.Errorf("archive user[%v]: %w", userId, err)
	}
	return nil
}
