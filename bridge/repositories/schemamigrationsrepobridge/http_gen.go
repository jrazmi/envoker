// Code generated by bridgegen. DO NOT EDIT.
// This file contains HTTP handler methods.
// Route registration is in http.go (user-editable).

package schemamigrationsrepobridge

import (
	"context"
	"net/http"

	"github.com/jrazmi/envoker/bridge/scaffolding/errs"
	"github.com/jrazmi/envoker/bridge/scaffolding/fopbridge"
	"github.com/jrazmi/envoker/core/scaffolding/fop"
	"github.com/jrazmi/envoker/infrastructure/web"
)

// ============================================================================
// SUGGESTED ROUTES FOR http.go
// ============================================================================
// Copy the routes you need to http.go's AddHttpRoutes function:
//
//	//// Standard CRUD routes
//	// group.GET("/schema-migrations", b.httpList)
//	// group.GET("/schema-migrations/{version}", b.httpGetByID)
//	// group.POST("/schema-migrations", b.httpCreate)
//	// group.PUT("/schema-migrations/{version}", b.httpUpdate)
//	// group.DELETE("/schema-migrations/{version}", b.httpDelete)
// ============================================================================

// httpList handles GET requests for listing SchemaMigrations with pagination and filtering
func (b *bridge) httpList(ctx context.Context, r *http.Request) web.Encoder {
	qp := parseQueryParams(r)

	page, err := fop.ParsePageStringCursor(qp.Limit, qp.Cursor)
	if err != nil {
		return errs.NewFieldErrors("page", err)
	}

	filter, err := parseFilter(qp)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid filter: %s", err)
	}

	orderBy := parseOrderBy(qp.Order)

	records, pagination, err := b.schemaMigrationRepository.List(ctx, filter, orderBy, page)
	if err != nil {
		return errs.Newf(errs.Internal, "list SchemaMigrations: %s", err)
	}

	return fopbridge.NewPaginatedResult(MarshalListToBridge(records), pagination)
}

// httpGetByID handles GET requests for retrieving a specific schemaMigration by ID
func (b *bridge) httpGetByID(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parsePath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	if qpath.Version == "" {
		return errs.Newf(errs.InvalidArgument, "version is required")
	}

	record, err := b.schemaMigrationRepository.Get(ctx, qpath.Version)
	if err != nil {
		return errs.Newf(errs.NotFound, "schemaMigration not found: %s", qpath.Version)
	}

	return MarshalToBridge(record)
}

// httpCreate handles POST requests for creating a new schemaMigration
func (b *bridge) httpCreate(ctx context.Context, r *http.Request) web.Encoder {
	var input CreateSchemaMigrationInput
	if err := web.Decode(r, &input); err != nil {
		return errs.Newf(errs.InvalidArgument, "decode: %s", err)
	}

	createInput := MarshalCreateToRepository(input)

	record, err := b.schemaMigrationRepository.Create(ctx, createInput)
	if err != nil {
		return errs.Newf(errs.Internal, "create schemaMigration: %s", err)
	}

	return MarshalToBridge(record)
}

// httpUpdate handles PUT/PATCH requests for updating an existing schemaMigration
func (b *bridge) httpUpdate(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parsePath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	if qpath.Version == "" {
		return errs.Newf(errs.InvalidArgument, "version is required")
	}

	var input UpdateSchemaMigrationInput
	if err := web.Decode(r, &input); err != nil {
		return errs.Newf(errs.InvalidArgument, "decode: %s", err)
	}

	updateInput := MarshalUpdateToRepository(input)

	err = b.schemaMigrationRepository.Update(ctx, qpath.Version, updateInput)
	if err != nil {
		return errs.Newf(errs.Internal, "update schemaMigration: %s", err)
	}

	return fopbridge.CodeResponse{
		Code:    errs.OK.String(),
		Message: "SchemaMigration updated successfully",
	}
}

// httpDelete handles DELETE requests for removing a schemaMigration
func (b *bridge) httpDelete(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parsePath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	if qpath.Version == "" {
		return errs.Newf(errs.InvalidArgument, "version is required")
	}

	err = b.schemaMigrationRepository.Delete(ctx, qpath.Version)
	if err != nil {
		return errs.Newf(errs.Internal, "delete schemaMigration: %s", err)
	}

	return fopbridge.CodeResponse{
		Code:    errs.OK.String(),
		Message: "SchemaMigration deleted successfully",
	}
}
