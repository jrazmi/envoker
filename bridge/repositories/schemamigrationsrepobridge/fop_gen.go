// Code generated by bridgegen. DO NOT EDIT.

package schemamigrationsrepobridge

import (
	"fmt"
	"net/http"
	"time"

	"github.com/jrazmi/envoker/core/repositories/schemamigrationsrepo"
	"github.com/jrazmi/envoker/core/scaffolding/fop"
)

// queryParams holds raw query string values from the HTTP request
type queryParams struct {
	Limit  string
	Cursor string
	Order  string
	// Filter fields
	SearchTerm string
	Checksum   string
	AppliedAt  string
}

// pathParams holds path parameter values
type pathParams struct {
	Version string
}

// parseQueryParams extracts raw query string values
func parseQueryParams(r *http.Request) queryParams {
	q := r.URL.Query()
	return queryParams{
		Limit:      q.Get("limit"),
		Cursor:     q.Get("cursor"),
		Order:      q.Get("order"),
		SearchTerm: q.Get("search_term"),
		Checksum:   q.Get("checksum"),
		AppliedAt:  q.Get("applied_at"),
	}
}

// parseFilter converts query params to repository filter with validation
func parseFilter(qp queryParams) (schemamigrationsrepo.SchemaMigrationFilter, error) {
	filter := schemamigrationsrepo.SchemaMigrationFilter{}

	// SearchTerm filter
	if qp.SearchTerm != "" {
		filter.SearchTerm = &qp.SearchTerm
	}
	// Checksum - string filter
	if qp.Checksum != "" {
		filter.Checksum = &qp.Checksum
	}
	// AppliedAt - timestamp filter
	if qp.AppliedAt != "" {
		if t, err := time.Parse(time.RFC3339, qp.AppliedAt); err == nil {
			filter.AppliedAt = &t
		} else {
			return filter, fmt.Errorf("invalid applied_at format: %s", qp.AppliedAt)
		}
	}

	return filter, nil
}

// parsePath extracts path parameters
func parsePath(r *http.Request) (pathParams, error) {
	pp := pathParams{
		Version: r.PathValue("version"),
	}
	return pp, nil
}

// orderByFields maps URL-friendly field names to repository OrderBy constants
var orderByFields = map[string]string{
	"version":    schemamigrationsrepo.OrderByPK,
	"created_at": schemamigrationsrepo.OrderByCreatedAt,
	"updated_at": schemamigrationsrepo.OrderByUpdatedAt,
	"checksum":   schemamigrationsrepo.OrderByChecksum,
	"applied_at": schemamigrationsrepo.OrderByAppliedAt,
}

// parseOrderBy converts order query param to fop.By with validation
func parseOrderBy(order string) fop.By {
	if order == "" {
		return schemamigrationsrepo.DefaultOrderBy
	}

	// Use FOP's ParseOrder which handles "field,direction" format
	orderBy, err := fop.ParseOrder(orderByFields, order, schemamigrationsrepo.DefaultOrderBy)
	if err != nil {
		return schemamigrationsrepo.DefaultOrderBy
	}

	return orderBy
}
