// Code generated by bridgegen. DO NOT EDIT.
// This file is ALWAYS REGENERATED - do not modify.
// For customizations, see model.go and bridge.go which use type aliases and embedding.

package usersessionsrepobridge

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/jrazmi/envoker/bridge/scaffolding/errs"
	"github.com/jrazmi/envoker/bridge/scaffolding/fopbridge"
	"github.com/jrazmi/envoker/core/repositories/usersessionsrepo"
	"github.com/jrazmi/envoker/core/scaffolding/fop"
	"github.com/jrazmi/envoker/infrastructure/web"
)

// ========================================
// QUERY PARAMS & PATH PARAMS
// ========================================

// generatedQueryParams holds raw query string values from the HTTP request
type generatedQueryParams struct {
	Limit  string
	Cursor string
	Order  string
	// Filter fields
	SearchTerm       string
	UserId           string
	SessionToken     string
	RefreshToken     string
	IpAddress        string
	UserAgent        string
	ExpiresAt        string
	RefreshExpiresAt string
	Status           string
	LastActiveAt     string
}

// generatedPathParams holds path parameter values (parsed to their actual types)
type generatedPathParams struct {
	SessionId string
	UserId    string
}

// parseGeneratedQueryParams extracts raw query string values
func parseGeneratedQueryParams(r *http.Request) generatedQueryParams {
	q := r.URL.Query()
	return generatedQueryParams{
		Limit:            q.Get("limit"),
		Cursor:           q.Get("cursor"),
		Order:            q.Get("order"),
		SearchTerm:       q.Get("search_term"),
		UserId:           q.Get("user_id"),
		SessionToken:     q.Get("session_token"),
		RefreshToken:     q.Get("refresh_token"),
		IpAddress:        q.Get("ip_address"),
		UserAgent:        q.Get("user_agent"),
		ExpiresAt:        q.Get("expires_at"),
		RefreshExpiresAt: q.Get("refresh_expires_at"),
		Status:           q.Get("status"),
		LastActiveAt:     q.Get("last_active_at"),
	}
}

// parseGeneratedFilter converts query params to repository filter with validation
func parseGeneratedFilter(qp generatedQueryParams) (usersessionsrepo.UserSessionFilter, error) {
	filter := usersessionsrepo.UserSessionFilter{}

	// SearchTerm filter
	if qp.SearchTerm != "" {
		filter.SearchTerm = &qp.SearchTerm
	}
	// UserId - string filter
	if qp.UserId != "" {
		filter.UserId = &qp.UserId
	}
	// SessionToken - string filter
	if qp.SessionToken != "" {
		filter.SessionToken = &qp.SessionToken
	}
	// RefreshToken - string filter
	if qp.RefreshToken != "" {
		filter.RefreshToken = &qp.RefreshToken
	}
	// IpAddress - string filter
	if qp.IpAddress != "" {
		filter.IpAddress = &qp.IpAddress
	}
	// UserAgent - string filter
	if qp.UserAgent != "" {
		filter.UserAgent = &qp.UserAgent
	}
	// ExpiresAt - timestamp filter
	if qp.ExpiresAt != "" {
		if t, err := time.Parse(time.RFC3339, qp.ExpiresAt); err == nil {
			filter.ExpiresAt = &t
		} else {
			return filter, fmt.Errorf("invalid expires_at format: %s", qp.ExpiresAt)
		}
	}
	// RefreshExpiresAt - timestamp filter
	if qp.RefreshExpiresAt != "" {
		if t, err := time.Parse(time.RFC3339, qp.RefreshExpiresAt); err == nil {
			filter.RefreshExpiresAt = &t
		} else {
			return filter, fmt.Errorf("invalid refresh_expires_at format: %s", qp.RefreshExpiresAt)
		}
	}
	// Status - string filter
	if qp.Status != "" {
		filter.Status = &qp.Status
	}
	// LastActiveAt - timestamp filter
	if qp.LastActiveAt != "" {
		if t, err := time.Parse(time.RFC3339, qp.LastActiveAt); err == nil {
			filter.LastActiveAt = &t
		} else {
			return filter, fmt.Errorf("invalid last_active_at format: %s", qp.LastActiveAt)
		}
	}

	return filter, nil
}

// parseGeneratedPath extracts and parses path parameters to their actual types
func parseGeneratedPath(r *http.Request) (generatedPathParams, error) {
	var pp generatedPathParams

	// Parse primary key
	pkStr := r.PathValue("session_id")
	if pkStr == "" {
		return pp, fmt.Errorf("session_id is required")
	}
	pp.SessionId = pkStr
	// Parse foreign key: UserId
	fkStrUserId := r.PathValue("user_id")
	if fkStrUserId != "" {
		pp.UserId = fkStrUserId
	}

	return pp, nil
}

// orderByFields maps URL-friendly field names to repository OrderBy constants
var orderByFields = map[string]string{
	"session_id":         usersessionsrepo.OrderByPK,
	"created_at":         usersessionsrepo.OrderByCreatedAt,
	"updated_at":         usersessionsrepo.OrderByUpdatedAt,
	"user_id":            usersessionsrepo.OrderByUserId,
	"session_token":      usersessionsrepo.OrderBySessionToken,
	"refresh_token":      usersessionsrepo.OrderByRefreshToken,
	"ip_address":         usersessionsrepo.OrderByIpAddress,
	"user_agent":         usersessionsrepo.OrderByUserAgent,
	"expires_at":         usersessionsrepo.OrderByExpiresAt,
	"refresh_expires_at": usersessionsrepo.OrderByRefreshExpiresAt,
	"status":             usersessionsrepo.OrderByStatus,
	"last_active_at":     usersessionsrepo.OrderByLastActiveAt,
}

// parseGeneratedOrderBy converts order query param to fop.By with validation
func parseGeneratedOrderBy(order string) fop.By {
	if order == "" {
		return usersessionsrepo.DefaultOrderBy
	}

	// Use FOP's ParseOrder which handles "field,direction" format
	orderBy, err := fop.ParseOrder(orderByFields, order, usersessionsrepo.DefaultOrderBy)
	if err != nil {
		return usersessionsrepo.DefaultOrderBy
	}

	return orderBy
}

// ========================================
// GENERATED BRIDGE (HTTP HANDLERS)
// ========================================

// GeneratedBridge provides default HTTP handler implementations.
// Embed this in your custom bridge struct to inherit default handlers.
// The bridge is tightly coupled to the repository - it directly uses the concrete repository type.
type GeneratedBridge struct {
	userSessionRepository *usersessionsrepo.Repository
}

// ============================================================================
// SUGGESTED ROUTES FOR http.go
// ============================================================================
// Copy these routes to http.go's AddHttpRoutes function.
// If new foreign keys are added by migrations, new routes will appear here.
//
//	// Standard CRUD routes
//	group.GET("/user-sessions", b.httpList)
//	group.GET("/user-sessions/{session_id}", b.httpGetByID)
//	group.POST("/user-sessions", b.httpCreate)
//	group.PUT("/user-sessions/{session_id}", b.httpUpdate)
//	group.DELETE("/user-sessions/{session_id}", b.httpDelete)
//
//	// Foreign key routes
//	group.GET("/users/{user_id}/user-sessions", b.httpListByUserId)
// ============================================================================

// httpList handles GET requests for listing UserSessions with pagination and filtering
func (b *GeneratedBridge) httpList(ctx context.Context, r *http.Request) web.Encoder {
	qp := parseGeneratedQueryParams(r)

	page, err := fop.ParsePageStringCursor(qp.Limit, qp.Cursor)
	if err != nil {
		return errs.NewFieldErrors("page", err)
	}

	filter, err := parseGeneratedFilter(qp)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid filter: %s", err)
	}

	orderBy := parseGeneratedOrderBy(qp.Order)

	records, pagination, err := b.userSessionRepository.List(ctx, filter, orderBy, page)
	if err != nil {
		return errs.Newf(errs.Internal, "list UserSessions: %s", err)
	}

	return fopbridge.NewPaginatedResult(records, pagination)
}

// httpGetByID handles GET requests for retrieving a specific userSession by ID
func (b *GeneratedBridge) httpGetByID(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parseGeneratedPath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	record, err := b.userSessionRepository.Get(ctx, qpath.SessionId)
	if err != nil {
		return errs.Newf(errs.NotFound, "userSession not found: %v", qpath.SessionId)
	}

	return fopbridge.NewRecordResponse(record)
}

// httpCreate handles POST requests for creating a new userSession
func (b *GeneratedBridge) httpCreate(ctx context.Context, r *http.Request) web.Encoder {
	var input usersessionsrepo.CreateUserSession
	if err := web.Decode(r, &input); err != nil {
		return errs.Newf(errs.InvalidArgument, "decode: %s", err)
	}

	record, err := b.userSessionRepository.Create(ctx, input)
	if err != nil {
		return errs.Newf(errs.Internal, "create userSession: %s", err)
	}

	return fopbridge.NewRecordResponse(record)
}

// httpUpdate handles PUT/PATCH requests for updating an existing userSession
func (b *GeneratedBridge) httpUpdate(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parseGeneratedPath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	var input usersessionsrepo.UpdateUserSession
	if err := web.Decode(r, &input); err != nil {
		return errs.Newf(errs.InvalidArgument, "decode: %s", err)
	}

	err = b.userSessionRepository.Update(ctx, qpath.SessionId, input)
	if err != nil {
		return errs.Newf(errs.Internal, "update userSession: %s", err)
	}

	return fopbridge.NewCodeResponse(errs.OK.String(), "UserSession updated successfully")
}

// httpDelete handles DELETE requests for removing a userSession
func (b *GeneratedBridge) httpDelete(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parseGeneratedPath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	err = b.userSessionRepository.Delete(ctx, qpath.SessionId)
	if err != nil {
		return errs.Newf(errs.Internal, "delete userSession: %s", err)
	}

	return fopbridge.NewCodeResponse(errs.OK.String(), "UserSession deleted successfully")
}

// httpListByUserId handles GET requests for listing UserSessions by User
func (b *GeneratedBridge) httpListByUserId(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parseGeneratedPath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	qp := parseGeneratedQueryParams(r)

	page, err := fop.ParsePageStringCursor(qp.Limit, qp.Cursor)
	if err != nil {
		return errs.NewFieldErrors("page", err)
	}

	orderBy := parseGeneratedOrderBy(qp.Order)

	records, pagination, err := b.userSessionRepository.ListByUserId(ctx, qpath.UserId, orderBy, page)
	if err != nil {
		return errs.Newf(errs.Internal, "list UserSessions by UserId: %s", err)
	}

	return fopbridge.NewPaginatedResult(records, pagination)
}
