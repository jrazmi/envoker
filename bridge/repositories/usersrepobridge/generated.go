// Code generated by bridgegen. DO NOT EDIT.
// This file is ALWAYS REGENERATED - do not modify.
// For customizations, see model.go and bridge.go which use type aliases and embedding.

package usersrepobridge

import (
	"context"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/jrazmi/envoker/bridge/scaffolding/errs"
	"github.com/jrazmi/envoker/bridge/scaffolding/fopbridge"
	"github.com/jrazmi/envoker/core/repositories/usersrepo"
	"github.com/jrazmi/envoker/core/scaffolding/fop"
	"github.com/jrazmi/envoker/infrastructure/web"
)

// ========================================
// QUERY PARAMS & PATH PARAMS
// ========================================

// generatedQueryParams holds raw query string values from the HTTP request
type generatedQueryParams struct {
	Limit  string
	Cursor string
	Order  string
	// Filter fields
	SearchTerm             string
	Email                  string
	Username               string
	PasswordHash           string
	PasswordSalt           string
	FirstName              string
	LastName               string
	DisplayName            string
	EmailVerified          string
	EmailVerifiedAt        string
	Role                   string
	LastLoginAt            string
	LastLoginIp            string
	FailedLoginAttempts    string
	LockedUntil            string
	PasswordResetToken     string
	PasswordResetExpiresAt string
	Status                 string
}

// generatedPathParams holds path parameter values (parsed to their actual types)
type generatedPathParams struct {
	UserId string
}

// parseGeneratedQueryParams extracts raw query string values
func parseGeneratedQueryParams(r *http.Request) generatedQueryParams {
	q := r.URL.Query()
	return generatedQueryParams{
		Limit:                  q.Get("limit"),
		Cursor:                 q.Get("cursor"),
		Order:                  q.Get("order"),
		SearchTerm:             q.Get("search_term"),
		Email:                  q.Get("email"),
		Username:               q.Get("username"),
		PasswordHash:           q.Get("password_hash"),
		PasswordSalt:           q.Get("password_salt"),
		FirstName:              q.Get("first_name"),
		LastName:               q.Get("last_name"),
		DisplayName:            q.Get("display_name"),
		EmailVerified:          q.Get("email_verified"),
		EmailVerifiedAt:        q.Get("email_verified_at"),
		Role:                   q.Get("role"),
		LastLoginAt:            q.Get("last_login_at"),
		LastLoginIp:            q.Get("last_login_ip"),
		FailedLoginAttempts:    q.Get("failed_login_attempts"),
		LockedUntil:            q.Get("locked_until"),
		PasswordResetToken:     q.Get("password_reset_token"),
		PasswordResetExpiresAt: q.Get("password_reset_expires_at"),
		Status:                 q.Get("status"),
	}
}

// parseGeneratedFilter converts query params to repository filter with validation
func parseGeneratedFilter(qp generatedQueryParams) (usersrepo.UserFilter, error) {
	filter := usersrepo.UserFilter{}

	// SearchTerm filter
	if qp.SearchTerm != "" {
		filter.SearchTerm = &qp.SearchTerm
	}
	// Email - string filter
	if qp.Email != "" {
		filter.Email = &qp.Email
	}
	// Username - string filter
	if qp.Username != "" {
		filter.Username = &qp.Username
	}
	// PasswordHash - string filter
	if qp.PasswordHash != "" {
		filter.PasswordHash = &qp.PasswordHash
	}
	// PasswordSalt - string filter
	if qp.PasswordSalt != "" {
		filter.PasswordSalt = &qp.PasswordSalt
	}
	// FirstName - string filter
	if qp.FirstName != "" {
		filter.FirstName = &qp.FirstName
	}
	// LastName - string filter
	if qp.LastName != "" {
		filter.LastName = &qp.LastName
	}
	// DisplayName - string filter
	if qp.DisplayName != "" {
		filter.DisplayName = &qp.DisplayName
	}
	// EmailVerified - boolean filter
	if qp.EmailVerified != "" {
		if val, err := strconv.ParseBool(qp.EmailVerified); err == nil {
			filter.EmailVerified = &val
		} else {
			return filter, fmt.Errorf("invalid email_verified: %s (expected true/false)", qp.EmailVerified)
		}
	}
	// EmailVerifiedAt - timestamp filter
	if qp.EmailVerifiedAt != "" {
		if t, err := time.Parse(time.RFC3339, qp.EmailVerifiedAt); err == nil {
			filter.EmailVerifiedAt = &t
		} else {
			return filter, fmt.Errorf("invalid email_verified_at format: %s", qp.EmailVerifiedAt)
		}
	}
	// Role - string filter
	if qp.Role != "" {
		filter.Role = &qp.Role
	}
	// LastLoginAt - timestamp filter
	if qp.LastLoginAt != "" {
		if t, err := time.Parse(time.RFC3339, qp.LastLoginAt); err == nil {
			filter.LastLoginAt = &t
		} else {
			return filter, fmt.Errorf("invalid last_login_at format: %s", qp.LastLoginAt)
		}
	}
	// LastLoginIp - string filter
	if qp.LastLoginIp != "" {
		filter.LastLoginIp = &qp.LastLoginIp
	}
	// FailedLoginAttempts - int filter
	if qp.FailedLoginAttempts != "" {
		if val, err := strconv.Atoi(qp.FailedLoginAttempts); err == nil {
			filter.FailedLoginAttempts = &val
		} else {
			return filter, fmt.Errorf("invalid failed_login_attempts: %s", qp.FailedLoginAttempts)
		}
	}
	// LockedUntil - timestamp filter
	if qp.LockedUntil != "" {
		if t, err := time.Parse(time.RFC3339, qp.LockedUntil); err == nil {
			filter.LockedUntil = &t
		} else {
			return filter, fmt.Errorf("invalid locked_until format: %s", qp.LockedUntil)
		}
	}
	// PasswordResetToken - string filter
	if qp.PasswordResetToken != "" {
		filter.PasswordResetToken = &qp.PasswordResetToken
	}
	// PasswordResetExpiresAt - timestamp filter
	if qp.PasswordResetExpiresAt != "" {
		if t, err := time.Parse(time.RFC3339, qp.PasswordResetExpiresAt); err == nil {
			filter.PasswordResetExpiresAt = &t
		} else {
			return filter, fmt.Errorf("invalid password_reset_expires_at format: %s", qp.PasswordResetExpiresAt)
		}
	}
	// Status - string filter
	if qp.Status != "" {
		filter.Status = &qp.Status
	}

	return filter, nil
}

// parseGeneratedPath extracts and parses path parameters to their actual types
func parseGeneratedPath(r *http.Request) (generatedPathParams, error) {
	var pp generatedPathParams

	// Parse primary key
	pkStr := r.PathValue("user_id")
	if pkStr == "" {
		return pp, fmt.Errorf("user_id is required")
	}
	pp.UserId = pkStr

	return pp, nil
}

// orderByFields maps URL-friendly field names to repository OrderBy constants
var orderByFields = map[string]string{
	"user_id":                   usersrepo.OrderByPK,
	"created_at":                usersrepo.OrderByCreatedAt,
	"updated_at":                usersrepo.OrderByUpdatedAt,
	"email":                     usersrepo.OrderByEmail,
	"username":                  usersrepo.OrderByUsername,
	"password_hash":             usersrepo.OrderByPasswordHash,
	"password_salt":             usersrepo.OrderByPasswordSalt,
	"first_name":                usersrepo.OrderByFirstName,
	"last_name":                 usersrepo.OrderByLastName,
	"display_name":              usersrepo.OrderByDisplayName,
	"email_verified":            usersrepo.OrderByEmailVerified,
	"email_verified_at":         usersrepo.OrderByEmailVerifiedAt,
	"role":                      usersrepo.OrderByRole,
	"last_login_at":             usersrepo.OrderByLastLoginAt,
	"last_login_ip":             usersrepo.OrderByLastLoginIp,
	"failed_login_attempts":     usersrepo.OrderByFailedLoginAttempts,
	"locked_until":              usersrepo.OrderByLockedUntil,
	"password_reset_token":      usersrepo.OrderByPasswordResetToken,
	"password_reset_expires_at": usersrepo.OrderByPasswordResetExpiresAt,
	"status":                    usersrepo.OrderByStatus,
}

// parseGeneratedOrderBy converts order query param to fop.By with validation
func parseGeneratedOrderBy(order string) fop.By {
	if order == "" {
		return usersrepo.DefaultOrderBy
	}

	// Use FOP's ParseOrder which handles "field,direction" format
	orderBy, err := fop.ParseOrder(orderByFields, order, usersrepo.DefaultOrderBy)
	if err != nil {
		return usersrepo.DefaultOrderBy
	}

	return orderBy
}

// ========================================
// GENERATED BRIDGE (HTTP HANDLERS)
// ========================================

// GeneratedBridge provides default HTTP handler implementations.
// Embed this in your custom bridge struct to inherit default handlers.
// The bridge is tightly coupled to the repository - it directly uses the concrete repository type.
type GeneratedBridge struct {
	userRepository *usersrepo.Repository
}

// ============================================================================
// SUGGESTED ROUTES FOR http.go
// ============================================================================
// Copy these routes to http.go's AddHttpRoutes function.
// If new foreign keys are added by migrations, new routes will appear here.
//
//	// Standard CRUD routes
//	group.GET("/users", b.httpList)
//	group.GET("/users/{user_id}", b.httpGetByID)
//	group.POST("/users", b.httpCreate)
//	group.PUT("/users/{user_id}", b.httpUpdate)
//	group.DELETE("/users/{user_id}", b.httpDelete)
// ============================================================================

// httpList handles GET requests for listing Users with pagination and filtering
func (b *GeneratedBridge) httpList(ctx context.Context, r *http.Request) web.Encoder {
	qp := parseGeneratedQueryParams(r)

	page, err := fop.ParsePageStringCursor(qp.Limit, qp.Cursor)
	if err != nil {
		return errs.NewFieldErrors("page", err)
	}

	filter, err := parseGeneratedFilter(qp)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid filter: %s", err)
	}

	orderBy := parseGeneratedOrderBy(qp.Order)

	records, pagination, err := b.userRepository.List(ctx, filter, orderBy, page)
	if err != nil {
		return errs.Newf(errs.Internal, "list Users: %s", err)
	}

	return fopbridge.NewPaginatedResult(records, pagination)
}

// httpGetByID handles GET requests for retrieving a specific user by ID
func (b *GeneratedBridge) httpGetByID(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parseGeneratedPath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	record, err := b.userRepository.Get(ctx, qpath.UserId)
	if err != nil {
		return errs.Newf(errs.NotFound, "user not found: %v", qpath.UserId)
	}

	return fopbridge.NewRecordResponse(record)
}

// httpCreate handles POST requests for creating a new user
func (b *GeneratedBridge) httpCreate(ctx context.Context, r *http.Request) web.Encoder {
	var input usersrepo.CreateUser
	if err := web.Decode(r, &input); err != nil {
		return errs.Newf(errs.InvalidArgument, "decode: %s", err)
	}

	record, err := b.userRepository.Create(ctx, input)
	if err != nil {
		return errs.Newf(errs.Internal, "create user: %s", err)
	}

	return fopbridge.NewRecordResponse(record)
}

// httpUpdate handles PUT/PATCH requests for updating an existing user
func (b *GeneratedBridge) httpUpdate(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parseGeneratedPath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	var input usersrepo.UpdateUser
	if err := web.Decode(r, &input); err != nil {
		return errs.Newf(errs.InvalidArgument, "decode: %s", err)
	}

	err = b.userRepository.Update(ctx, qpath.UserId, input)
	if err != nil {
		return errs.Newf(errs.Internal, "update user: %s", err)
	}

	return fopbridge.NewCodeResponse(errs.OK.String(), "User updated successfully")
}

// httpDelete handles DELETE requests for removing a user
func (b *GeneratedBridge) httpDelete(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parseGeneratedPath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	err = b.userRepository.Delete(ctx, qpath.UserId)
	if err != nil {
		return errs.Newf(errs.Internal, "delete user: %s", err)
	}

	return fopbridge.NewCodeResponse(errs.OK.String(), "User deleted successfully")
}
