// Code generated by bridgegen. DO NOT EDIT.
// This file contains HTTP handler methods.
// Route registration is in http.go (user-editable).

package tasksrepobridge

import (
	"context"
	"net/http"

	"github.com/jrazmi/envoker/bridge/scaffolding/errs"
	"github.com/jrazmi/envoker/bridge/scaffolding/fopbridge"
	"github.com/jrazmi/envoker/core/scaffolding/fop"
	"github.com/jrazmi/envoker/infrastructure/web"
)

// ============================================================================
// SUGGESTED ROUTES FOR http.go
// ============================================================================
// Copy the routes you need to http.go's AddHttpRoutes function:
//
//	//// Standard CRUD routes
//	// group.GET("/tasks", b.httpList)
//	// group.GET("/tasks/{task_id}", b.httpGetByID)
//	// group.POST("/tasks", b.httpCreate)
//	// group.PUT("/tasks/{task_id}", b.httpUpdate)
//	// group.DELETE("/tasks/{task_id}", b.httpDelete)
// ============================================================================

// httpList handles GET requests for listing Tasks with pagination and filtering
func (b *bridge) httpList(ctx context.Context, r *http.Request) web.Encoder {
	qp := parseQueryParams(r)

	page, err := fop.ParsePageStringCursor(qp.Limit, qp.Cursor)
	if err != nil {
		return errs.NewFieldErrors("page", err)
	}

	filter, err := parseFilter(qp)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid filter: %s", err)
	}

	orderBy := parseOrderBy(qp.Order)

	records, pagination, err := b.taskRepository.List(ctx, filter, orderBy, page)
	if err != nil {
		return errs.Newf(errs.Internal, "list Tasks: %s", err)
	}

	return fopbridge.NewPaginatedResult(MarshalListToBridge(records), pagination)
}

// httpGetByID handles GET requests for retrieving a specific task by ID
func (b *bridge) httpGetByID(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parsePath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	if qpath.TaskId == "" {
		return errs.Newf(errs.InvalidArgument, "task_id is required")
	}

	record, err := b.taskRepository.Get(ctx, qpath.TaskId)
	if err != nil {
		return errs.Newf(errs.NotFound, "task not found: %s", qpath.TaskId)
	}

	return MarshalToBridge(record)
}

// httpCreate handles POST requests for creating a new task
func (b *bridge) httpCreate(ctx context.Context, r *http.Request) web.Encoder {
	var input CreateTaskInput
	if err := web.Decode(r, &input); err != nil {
		return errs.Newf(errs.InvalidArgument, "decode: %s", err)
	}

	createInput := MarshalCreateToRepository(input)

	record, err := b.taskRepository.Create(ctx, createInput)
	if err != nil {
		return errs.Newf(errs.Internal, "create task: %s", err)
	}

	return MarshalToBridge(record)
}

// httpUpdate handles PUT/PATCH requests for updating an existing task
func (b *bridge) httpUpdate(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parsePath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	if qpath.TaskId == "" {
		return errs.Newf(errs.InvalidArgument, "task_id is required")
	}

	var input UpdateTaskInput
	if err := web.Decode(r, &input); err != nil {
		return errs.Newf(errs.InvalidArgument, "decode: %s", err)
	}

	updateInput := MarshalUpdateToRepository(input)

	err = b.taskRepository.Update(ctx, qpath.TaskId, updateInput)
	if err != nil {
		return errs.Newf(errs.Internal, "update task: %s", err)
	}

	return fopbridge.CodeResponse{
		Code:    errs.OK.String(),
		Message: "Task updated successfully",
	}
}

// httpDelete handles DELETE requests for removing a task
func (b *bridge) httpDelete(ctx context.Context, r *http.Request) web.Encoder {
	qpath, err := parsePath(r)
	if err != nil {
		return errs.Newf(errs.InvalidArgument, "invalid path arguments: %s", err)
	}

	if qpath.TaskId == "" {
		return errs.Newf(errs.InvalidArgument, "task_id is required")
	}

	err = b.taskRepository.Delete(ctx, qpath.TaskId)
	if err != nil {
		return errs.Newf(errs.Internal, "delete task: %s", err)
	}

	return fopbridge.CodeResponse{
		Code:    errs.OK.String(),
		Message: "Task deleted successfully",
	}
}
