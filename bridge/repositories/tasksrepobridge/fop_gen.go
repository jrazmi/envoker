// Code generated by bridgegen. DO NOT EDIT.

package tasksrepobridge

import (
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/jrazmi/envoker/core/repositories/tasksrepo"
	"github.com/jrazmi/envoker/core/scaffolding/fop"
)

// queryParams holds raw query string values from the HTTP request
type queryParams struct {
	Limit  string
	Cursor string
	Order  string
	// Filter fields
	SearchTerm       string
	ProcessingStatus string
	TaskType         string
	Priority         string
	MaxRetries       string
	RetryCount       string
	ErrorMessage     string
	ProcessingTimeMs string
	LastRunAt        string
}

// pathParams holds path parameter values
type pathParams struct {
	TaskId string
}

// parseQueryParams extracts raw query string values
func parseQueryParams(r *http.Request) queryParams {
	q := r.URL.Query()
	return queryParams{
		Limit:            q.Get("limit"),
		Cursor:           q.Get("cursor"),
		Order:            q.Get("order"),
		SearchTerm:       q.Get("search_term"),
		ProcessingStatus: q.Get("processing_status"),
		TaskType:         q.Get("task_type"),
		Priority:         q.Get("priority"),
		MaxRetries:       q.Get("max_retries"),
		RetryCount:       q.Get("retry_count"),
		ErrorMessage:     q.Get("error_message"),
		ProcessingTimeMs: q.Get("processing_time_ms"),
		LastRunAt:        q.Get("last_run_at"),
	}
}

// parseFilter converts query params to repository filter with validation
func parseFilter(qp queryParams) (tasksrepo.TaskFilter, error) {
	filter := tasksrepo.TaskFilter{}

	// SearchTerm filter
	if qp.SearchTerm != "" {
		filter.SearchTerm = &qp.SearchTerm
	}
	// ProcessingStatus - string filter
	if qp.ProcessingStatus != "" {
		filter.ProcessingStatus = &qp.ProcessingStatus
	}
	// TaskType - string filter
	if qp.TaskType != "" {
		filter.TaskType = &qp.TaskType
	}
	// Priority - int filter
	if qp.Priority != "" {
		if val, err := strconv.Atoi(qp.Priority); err == nil {
			filter.Priority = &val
		} else {
			return filter, fmt.Errorf("invalid priority: %s", qp.Priority)
		}
	}
	// MaxRetries - int filter
	if qp.MaxRetries != "" {
		if val, err := strconv.Atoi(qp.MaxRetries); err == nil {
			filter.MaxRetries = &val
		} else {
			return filter, fmt.Errorf("invalid max_retries: %s", qp.MaxRetries)
		}
	}
	// RetryCount - int filter
	if qp.RetryCount != "" {
		if val, err := strconv.Atoi(qp.RetryCount); err == nil {
			filter.RetryCount = &val
		} else {
			return filter, fmt.Errorf("invalid retry_count: %s", qp.RetryCount)
		}
	}
	// ErrorMessage - string filter
	if qp.ErrorMessage != "" {
		filter.ErrorMessage = &qp.ErrorMessage
	}
	// ProcessingTimeMs - int filter
	if qp.ProcessingTimeMs != "" {
		if val, err := strconv.Atoi(qp.ProcessingTimeMs); err == nil {
			filter.ProcessingTimeMs = &val
		} else {
			return filter, fmt.Errorf("invalid processing_time_ms: %s", qp.ProcessingTimeMs)
		}
	}
	// LastRunAt - timestamp filter
	if qp.LastRunAt != "" {
		if t, err := time.Parse(time.RFC3339, qp.LastRunAt); err == nil {
			filter.LastRunAt = &t
		} else {
			return filter, fmt.Errorf("invalid last_run_at format: %s", qp.LastRunAt)
		}
	}

	return filter, nil
}

// parsePath extracts path parameters
func parsePath(r *http.Request) (pathParams, error) {
	pp := pathParams{
		TaskId: r.PathValue("task_id"),
	}
	return pp, nil
}

// orderByFields maps URL-friendly field names to repository OrderBy constants
var orderByFields = map[string]string{
	"task_id":            tasksrepo.OrderByPK,
	"created_at":         tasksrepo.OrderByCreatedAt,
	"updated_at":         tasksrepo.OrderByUpdatedAt,
	"processing_status":  tasksrepo.OrderByProcessingStatus,
	"task_type":          tasksrepo.OrderByTaskType,
	"priority":           tasksrepo.OrderByPriority,
	"max_retries":        tasksrepo.OrderByMaxRetries,
	"retry_count":        tasksrepo.OrderByRetryCount,
	"error_message":      tasksrepo.OrderByErrorMessage,
	"processing_time_ms": tasksrepo.OrderByProcessingTimeMs,
	"last_run_at":        tasksrepo.OrderByLastRunAt,
}

// parseOrderBy converts order query param to fop.By with validation
func parseOrderBy(order string) fop.By {
	if order == "" {
		return tasksrepo.DefaultOrderBy
	}

	// Use FOP's ParseOrder which handles "field,direction" format
	orderBy, err := fop.ParseOrder(orderByFields, order, tasksrepo.DefaultOrderBy)
	if err != nil {
		return tasksrepo.DefaultOrderBy
	}

	return orderBy
}
